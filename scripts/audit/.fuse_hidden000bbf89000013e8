#!/usr/bin/env bash
#
# rule-compliance.sh - Automated compliance checking against workspace rules
# Checks: test coverage, hardcoded secrets, file size limits, branch naming
#

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Counters
PASS_COUNT=0
FAIL_COUNT=0
WARN_COUNT=0

# Configuration
COVERAGE_THRESHOLD=80
MAX_FILE_LINES=400
BRANCH_PREFIXES="feature|bugfix|hotfix|chore|docs|refactor"

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Automated compliance checking against workspace rules.

OPTIONS:
    -h, --help          Show this help message
    -v, --verbose       Verbose output
    -d, --dir DIR       Target directory (default: current)
    --skip-coverage     Skip coverage check
    --skip-secrets      Skip secrets check
    --skip-size         Skip file size check
    --skip-branch       Skip branch naming check

CHECKS:
    1. Test coverage >= 80% (from coverage reports)
    2. No hardcoded secrets (API keys, passwords, tokens)
    3. File size <= 400 lines (per coding-style.md)
    4. Branch naming follows convention (feature/, bugfix/, etc.)

EXIT CODES:
    0   All checks passed
    1   One or more checks failed
EOF
}

# Logging functions
pass() { echo -e "${GREEN}[PASS]${NC} $1"; ((PASS_COUNT++)); }
fail() { echo -e "${RED}[FAIL]${NC} $1"; ((FAIL_COUNT++)); }
warn() { echo -e "${YELLOW}[WARN]${NC} $1"; ((WARN_COUNT++)); }
info() { echo -e "${BLUE}[INFO]${NC} $1"; }

# Parse arguments
VERBOSE=false
TARGET_DIR="."
SKIP_COVERAGE=false
SKIP_SECRETS=false
SKIP_SIZE=false
SKIP_BRANCH=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help) usage; exit 0 ;;
        -v|--verbose) VERBOSE=true; shift ;;
        -d|--dir) TARGET_DIR="$2"; shift 2 ;;
        --skip-coverage) SKIP_COVERAGE=true; shift ;;
        --skip-secrets) SKIP_SECRETS=true; shift ;;
        --skip-size) SKIP_SIZE=true; shift ;;
        --skip-branch) SKIP_BRANCH=true; shift ;;
        *) echo "Unknown option: $1"; usage; exit 1 ;;
    esac
done

cd "$TARGET_DIR"
info "Running compliance checks in: $(pwd)"
echo ""

# Check 1: Test Coverage
check_coverage() {
    info "Checking test coverage (threshold: ${COVERAGE_THRESHOLD}%)..."

    # Look for common coverage report locations
    local coverage_found=false
    local coverage_pct=0

    # Python coverage.py
    if [[ -f ".coverage" ]] || [[ -f "coverage.xml" ]] || [[ -f "htmlcov/index.html" ]]; then
        if command -v coverage &>/dev/null && [[ -f ".coverage" ]]; then
            coverage_pct=$(coverage report 2>/dev/null | grep -oP 'TOTAL.*\s+(\d+)%' | grep -oP '\d+(?=%)' || echo "0")
            coverage_found=true
        fi
    fi

    # Jest/NYC coverage
    if [[ -f "coverage/coverage-summary.json" ]]; then
        coverage_pct=$(jq -r '.total.lines.pct // 0' coverage/coverage-summary.json 2>/dev/null | cut -d. -f1)
        coverage_found=true
    fi

    # Go coverage
    if [[ -f "coverage.out" ]]; then
        coverage_pct=$(go tool cover -func=coverage.out 2>/dev/null | grep total | awk '{print $3}' | tr -d '%' | cut -d. -f1 || echo "0")
        coverage_found=true
    fi

    if [[ "$coverage_found" == "false" ]]; then
        warn "No coverage reports found (looked for .coverage, coverage.xml, coverage/)"
        return
    fi

    if [[ "$coverage_pct" -ge "$COVERAGE_THRESHOLD" ]]; then
        pass "Coverage: ${coverage_pct}% >= ${COVERAGE_THRESHOLD}%"
    else
        fail "Coverage: ${coverage_pct}% < ${COVERAGE_THRESHOLD}% threshold"
    fi
}

# Check 2: Hardcoded Secrets
check_secrets() {
    info "Checking for hardcoded secrets..."

    local secret_patterns=(
        'API_KEY\s*=\s*["\x27][^"\x27]+'
        'api_key\s*=\s*["\x27][^"\x27]+'
        'PASSWORD\s*=\s*["\x27][^"\x27]+'
        'password\s*=\s*["\x27][^"\x27]+'
        'SECRET\s*=\s*["\x27][^"\x27]+'
        'secret\s*=\s*["\x27][^"\x27]+'
        'TOKEN\s*=\s*["\x27][^"\x27]+'
        'token\s*=\s*["\x27][^"\x27]+'
        'PRIVATE_KEY\s*=\s*["\x27][^"\x27]+'
        'AWS_ACCESS_KEY_ID\s*=\s*["\x27][^"\x27]+'
        'AWS_SECRET_ACCESS_KEY\s*=\s*["\x27][^"\x27]+'
    )

    local violations=()

    for pattern in "${secret_patterns[@]}"; do
        while IFS= read -r match; do
            [[ -n "$match" ]] && violations+=("$match")
        done < <(grep -rEn --include="*.py" --include="*.js" --include="*.ts" --include="*.go" \
                 --include="*.java" --include="*.rb" --include="*.sh" --include="*.yaml" --include="*.yml" \
                 --exclude-dir=node_modules --exclude-dir=.git --exclude-dir=vendor --exclude-dir=venv \
                 --exclude="*.example" --exclude=".env.example" \
                 "$pattern" . 2>/dev/null || true)
    done

    if [[ ${#violations[@]} -eq 0 ]]; then
        pass "No hardcoded secrets detected"
    else
        fail "Found ${#violations[@]} potential hardcoded secrets:"
        for v in "${violations[@]:0:5}"; do
            echo "       $v"
        done
        [[ ${#violations[@]} -gt 5 ]] && echo "       ... and $((${#violations[@]} - 5)) more"
    fi
}

# Check 3: File Size Limits
check_file_sizes() {
    info "Checking file sizes (max: ${MAX_FILE_LINES} lines)..."

    local oversized=()

    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        local lines
        lines=$(wc -l < "$file")
        if [[ "$lines" -gt "$MAX_FILE_LINES" ]]; then
            oversized+=("$file ($lines lines)")
        fi
    done < <(find . -type f \( -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.go" \
             -o -name "*.java" -o -name "*.rb" -o -name "*.sh" \) \
             -not -path "*/node_modules/*" -not -path "*/.git/*" \
             -not -path "*/vendor/*" -not -path "*/venv/*" 2>/dev/null)

    if [[ ${#oversized[@]} -eq 0 ]]; then
        pass "All source files within ${MAX_FILE_LINES} line limit"
    else
        fail "Found ${#oversized[@]} files exceeding ${MAX_FILE_LINES} lines:"
        for f in "${oversized[@]:0:5}"; do
            echo "       $f"
        done
        [[ ${#oversized[@]} -gt 5 ]] && echo "       ... and $((${#oversized[@]} - 5)) more"
    fi
}

# Check 4: Branch Naming Convention
check_branch_naming() {
    info "Checking branch naming convention..."

    if ! git rev-parse --git-dir &>/dev/null; then
        warn "Not a git repository, skipping branch check"
        return
    fi

    local branch
    branch=$(git branch --show-current 2>/dev/null || echo "")

    if [[ -z "$branch" ]]; then
        warn "Detached HEAD state, cannot check branch name"
        return
    fi

    # main/master are always valid
    if [[ "$branch" == "main" || "$branch" == "master" || "$branch" == "develop" ]]; then
        pass "Branch '$branch' is a protected branch"
        return
    fi

    if [[ "$branch" =~ ^($BRANCH_PREFIXES)/ ]]; then
        pass "Branch '$branch' follows naming convention"
    else
        fail "Branch '$branch' does not follow convention (expected: $BRANCH_PREFIXES)"
    fi
}

# Run checks
[[ "$SKIP_COVERAGE" == "false" ]] && check_coverage
[[ "$SKIP_SECRETS" == "false" ]] && check_secrets
[[ "$SKIP_SIZE" == "false" ]] && check_file_sizes
[[ "$SKIP_BRANCH" == "false" ]] && check_branch_naming

# Summary
echo ""
echo "============================================"
echo -e "  ${GREEN}PASSED${NC}: $PASS_COUNT"
echo -e "  ${RED}FAILED${NC}: $FAIL_COUNT"
echo -e "  ${YELLOW}WARNED${NC}: $WARN_COUNT"
echo "============================================"

if [[ "$FAIL_COUNT" -gt 0 ]]; then
    echo -e "${RED}Compliance check failed${NC}"
    exit 1
else
    echo -e "${GREEN}Compliance check passed${NC}"
    exit 0
fi
