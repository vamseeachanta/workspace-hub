#!/usr/bin/env python3
"""
ABOUTME: Map document index entries to calc_examples YAML blocks per engineering standard.
ABOUTME: Scores index records by keyword match to standard ID, outputs ready-to-paste YAML.

Usage:
    python3 calc-examples-mapper.py --standard DNV-OS-F101 --domain pipeline --top 5
    python3 calc-examples-mapper.py --standard DNV-RP-B401 --domain cathodic-protection --top 3
"""

import argparse
import json
import re
import sys
from pathlib import Path

HUB_ROOT = Path(__file__).resolve().parents[3]
INDEX_FILE = HUB_ROOT / "data" / "document-index" / "index.jsonl"

CALC_PATTERNS = re.compile(r"/CAL/|-CAL-|-RPT-", re.IGNORECASE)

STANDARD_ALIASES = {
    "DNV-OS-F101": ["dnv os f101", "dnv-os-f101", "osf101", "f101"],
    "DNV-RP-B401": ["dnv rp b401", "dnv-rp-b401", "rpb401", "b401"],
    "DNV-RP-F103": ["dnv rp f103", "dnv-rp-f103", "rpf103", "f103"],
    "DNV-RP-F109": ["dnv rp f109", "dnv-rp-f109", "f109"],
    "DNV-RP-F110": ["dnv rp f110", "dnv-rp-f110", "f110"],
    "API-RP-1111": ["api rp 1111", "api-rp-1111", "api1111", "1111"],
    "API-RP-2A-WSD": ["api rp 2a", "api-rp-2a", "2a-wsd", "api 2a"],
}


def score_record(rec: dict, standard: str, domain: str) -> int:
    """Score a record by relevance to a standard ID and domain."""
    path = rec.get("path", "")
    doc_number = str(rec.get("doc_number", "") or "")
    title = str(rec.get("title", "") or "")
    searchable = (path + " " + doc_number + " " + title).lower()

    std_lower = standard.lower()
    aliases = STANDARD_ALIASES.get(standard.upper(), [std_lower])

    # Standard must match via alias or expanded name; no match = skip
    std_score = 0
    for alias in aliases:
        if alias in searchable:
            std_score += 3
            break

    if standard.lower().replace("-", " ") in searchable:
        std_score += 2

    if std_score == 0:
        return 0

    score = std_score
    if CALC_PATTERNS.search(path):
        score += 2

    ext = rec.get("ext", "").lower()
    if ext in (".xlsx", ".xlsm", ".xls"):
        score += 1

    if domain and rec.get("domain") == domain:
        score += 1

    return score


def load_candidates(standard: str, domain: str, top: int) -> list[dict]:
    """Load and score index records, return top N."""
    if not INDEX_FILE.exists():
        print(f"ERROR: Index not found: {INDEX_FILE}", file=sys.stderr)
        sys.exit(1)

    scored = []
    with open(INDEX_FILE) as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                rec = json.loads(line)
            except json.JSONDecodeError:
                continue

            if domain and rec.get("domain") != domain:
                continue

            s = score_record(rec, standard, domain)
            if s > 0:
                scored.append((s, rec))

    scored.sort(key=lambda x: x[0], reverse=True)
    return [rec for _, rec in scored[:top]]


def format_yaml_block(standard: str, domain: str, records: list[dict]) -> str:
    """Format records as a calc_examples YAML block."""
    lines = [
        f"- standard: {standard}",
        f"  domain: {domain}",
        "  description: >",
        f"    Reference calculation files for {standard} ({domain} domain).",
        f"    Auto-generated by calc-examples-mapper.py â€” review and annotate before committing.",
        "  files:",
    ]
    for rec in records:
        path = rec.get("path", "")
        ext = rec.get("ext", "").lstrip(".")
        title = rec.get("title", "") or Path(path).name
        host = "ace-linux-1" if "/mnt/ace/" in path else "ace-linux-2"
        lines.append(f"  - path: {path}")
        lines.append(f"    description: {title}")
        lines.append(f"    type: {ext}")
        lines.append(f"    host: {host}")
    return "\n".join(lines)


def main() -> None:
    parser = argparse.ArgumentParser(description="Map index entries to calc_examples YAML block.")
    parser.add_argument("--standard", required=True, help="Standard ID (e.g. DNV-OS-F101)")
    parser.add_argument("--domain", default="", help="Engineering domain filter")
    parser.add_argument("--top", type=int, default=5, help="Number of top results (default: 5)")
    args = parser.parse_args()

    records = load_candidates(args.standard, args.domain, args.top)
    if not records:
        print(f"# No matching records found for standard={args.standard} domain={args.domain}")
        return

    print(format_yaml_block(args.standard, args.domain, records))


if __name__ == "__main__":
    main()
