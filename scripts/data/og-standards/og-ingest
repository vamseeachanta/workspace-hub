#!/bin/bash
# ABOUTME: O&G Standards Document Ingestion Pipeline
# ABOUTME: Add new documents to the knowledge base with automatic processing

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
STANDARDS_DIR="/mnt/ace/O&G-Standards"
DB_PATH="$STANDARDS_DIR/_inventory.db"

# Colors
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

# Force CPU mode
export CUDA_VISIBLE_DEVICES=""

usage() {
    echo -e "${BLUE}O&G Standards Document Ingestion Pipeline${NC}"
    echo ""
    echo "Usage: og-ingest <command> [options]"
    echo ""
    echo "Commands:"
    echo "  add <file|dir>     Add PDF file or directory to the library"
    echo "  scan               Scan for new documents and add to inventory"
    echo "  process            Process pending documents (extract + embed)"
    echo "  refresh            Full refresh: scan + inventory + extract + embed"
    echo "  status             Show ingestion status"
    echo ""
    echo "Examples:"
    echo "  og-ingest add /path/to/new_standard.pdf"
    echo "  og-ingest add /path/to/new_standards_folder/"
    echo "  og-ingest scan"
    echo "  og-ingest process"
    echo ""
}

add_document() {
    local source="$1"

    if [ -z "$source" ]; then
        echo -e "${RED}Error: No file or directory specified${NC}"
        usage
        return 1
    fi

    if [ ! -e "$source" ]; then
        echo -e "${RED}Error: '$source' not found${NC}"
        return 1
    fi

    # Determine organization from path or filename
    local basename=$(basename "$source")
    local org="Uncategorized"

    # Try to detect organization
    if [[ "$basename" =~ ^API || "$source" =~ /API/ ]]; then
        org="API"
    elif [[ "$basename" =~ ^DNV || "$source" =~ /DNV/ ]]; then
        org="DNV"
    elif [[ "$basename" =~ ^ASTM || "$source" =~ /ASTM/ ]]; then
        org="ASTM"
    elif [[ "$basename" =~ ^ISO || "$source" =~ /ISO/ ]]; then
        org="ISO"
    elif [[ "$basename" =~ ^Norsok || "$source" =~ /Norsok/ ]]; then
        org="Norsok"
    elif [[ "$basename" =~ ^BSI || "$source" =~ /BSI/ ]]; then
        org="BSI"
    fi

    # Create target directory
    local target_dir="$STANDARDS_DIR/$org"
    mkdir -p "$target_dir"

    if [ -f "$source" ]; then
        # Single file
        echo -e "${BLUE}Adding document: $basename${NC}"
        cp "$source" "$target_dir/"
        echo -e "${GREEN}✓ Copied to $target_dir/$basename${NC}"
    elif [ -d "$source" ]; then
        # Directory
        echo -e "${BLUE}Adding directory: $source${NC}"
        local count=$(find "$source" -type f -name "*.pdf" | wc -l)
        echo -e "   Found $count PDF files"

        find "$source" -type f -name "*.pdf" | while read pdf; do
            local pdf_name=$(basename "$pdf")
            cp "$pdf" "$target_dir/"
            echo -e "   ${GREEN}✓${NC} $pdf_name"
        done
    fi

    echo ""
    echo -e "${YELLOW}Run 'og-ingest process' to extract text and generate embeddings${NC}"
}

scan_documents() {
    echo -e "${BLUE}Scanning for documents...${NC}"
    cd "$SCRIPT_DIR"
    python inventory.py --scan-only 2>&1 | tail -20
}

process_pending() {
    echo -e "${BLUE}Processing pending documents...${NC}"
    echo ""

    # Step 1: Update inventory
    echo -e "${YELLOW}Step 1/3: Updating inventory...${NC}"
    cd "$SCRIPT_DIR"
    python inventory.py 2>&1 | tail -5

    # Step 2: Extract text
    echo ""
    echo -e "${YELLOW}Step 2/3: Extracting text from new PDFs...${NC}"
    python extract.py --limit 100 2>&1 | tail -10

    # Step 3: Generate embeddings
    echo ""
    echo -e "${YELLOW}Step 3/3: Generating embeddings...${NC}"
    python embed.py --model local --batch-size 50 --limit 500 2>&1 | tail -10

    echo ""
    echo -e "${GREEN}✓ Processing complete${NC}"
}

show_status() {
    echo -e "${BLUE}Ingestion Status${NC}"
    echo ""

    if [ ! -f "$DB_PATH" ]; then
        echo -e "${RED}Database not found. Run 'og-ingest scan' first.${NC}"
        return 1
    fi

    TOTAL=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM documents" 2>/dev/null || echo "0")
    EXTRACTED=$(sqlite3 "$DB_PATH" "SELECT COUNT(DISTINCT document_id) FROM text_chunks" 2>/dev/null || echo "0")
    CHUNKS=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM text_chunks" 2>/dev/null || echo "0")
    EMBEDDED=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM text_chunks WHERE embedding IS NOT NULL" 2>/dev/null || echo "0")

    PENDING_EXTRACT=$((TOTAL - EXTRACTED))
    PENDING_EMBED=$((CHUNKS - EMBEDDED))

    echo "  Total Documents:    $(printf "%'d" $TOTAL)"
    echo "  Pending Extraction: $(printf "%'d" $PENDING_EXTRACT)"
    echo "  Total Chunks:       $(printf "%'d" $CHUNKS)"
    echo "  Pending Embedding:  $(printf "%'d" $PENDING_EMBED)"
    echo ""

    if [ "$PENDING_EXTRACT" -gt 0 ] || [ "$PENDING_EMBED" -gt 0 ]; then
        echo -e "${YELLOW}Run 'og-ingest process' to process pending items${NC}"
    else
        echo -e "${GREEN}✓ All documents processed${NC}"
    fi
}

refresh_all() {
    echo -e "${BLUE}Full refresh starting...${NC}"
    echo ""

    # Step 1: Scan for new documents
    echo -e "${YELLOW}Step 1/4: Scanning for new documents...${NC}"
    cd "$SCRIPT_DIR"
    python inventory.py 2>&1 | tail -5

    # Step 2: Run extraction
    echo ""
    echo -e "${YELLOW}Step 2/4: Starting text extraction...${NC}"
    nohup python extract.py --batch-size 100 > /tmp/extract.log 2>&1 &
    EXTRACT_PID=$!
    echo "   Extraction started in background (PID: $EXTRACT_PID)"

    # Step 3: Run embedding
    echo ""
    echo -e "${YELLOW}Step 3/4: Starting embedding generation...${NC}"
    nohup python embed.py --model local --batch-size 100 > /tmp/embed.log 2>&1 &
    EMBED_PID=$!
    echo "   Embedding started in background (PID: $EMBED_PID)"

    # Step 4: Status
    echo ""
    echo -e "${YELLOW}Step 4/4: Status${NC}"
    show_status

    echo ""
    echo -e "${GREEN}✓ Refresh started in background${NC}"
    echo -e "  Use 'og-service logs' to monitor progress"
    echo -e "  Use 'og-status' to check current status"
}

case "$1" in
    add)
        add_document "$2"
        ;;
    scan)
        scan_documents
        ;;
    process)
        process_pending
        ;;
    refresh)
        refresh_all
        ;;
    status)
        show_status
        ;;
    *)
        usage
        ;;
esac
