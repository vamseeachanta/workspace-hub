---
id: WRK-661
title: "analysis(worldenergydata): dead code identification in common/legacy/ — Gemini call-site sweep"
status: pending
route: B
priority: medium
complexity: medium
compound: false
created_at: 2026-03-01T00:00:00Z
target_repos:
  - worldenergydata
commit:
spec_ref:
related:
  - WRK-568
blocked_by: []
synced_to: []
plan_reviewed: false
plan_approved: false
percent_complete: 0
brochure_status: n/a
computer: ace-linux-1
execution_workstations: [ace-linux-1]
plan_workstations: [ace-linux-1]
provider: gemini
orchestrator: gemini
cross_review: pending
---

# analysis(worldenergydata): Dead Code Identification in common/legacy/

## What

`worldenergydata/src/worldenergydata/common/legacy/` contains two large files:
- `ong_fd_components.py` — 1653 lines
- `wellpath3D.py` — 1251 lines

These were preserved during the God Object splits (WRK-568) but their live-caller
status is unknown. Use Gemini to read both legacy files plus all import/call sites
across the repo in one pass, then classify each top-level symbol as:
**dead** (no callers) | **migrated** (re-exported from new location) | **live** (direct callers).

## Plan

### Phase 1 — Build symbol + caller map (10 min)

```bash
cd worldenergydata

# Extract all top-level symbols from legacy files
python3 -c "
import ast, sys
for path in ['src/worldenergydata/common/legacy/ong_fd_components.py',
             'src/worldenergydata/common/legacy/wellpath3D.py']:
    tree = ast.parse(open(path).read())
    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
            if node.col_offset == 0:
                print(f'{path}::{node.name}')
" > /tmp/legacy_symbols.txt
wc -l /tmp/legacy_symbols.txt   # expected: 50-120 symbols
```

```bash
# Collect caller context: all .py files that import from or reference legacy
{
  echo "=== LEGACY FILES ==="
  cat src/worldenergydata/common/legacy/ong_fd_components.py \
      src/worldenergydata/common/legacy/wellpath3D.py

  echo "=== ALL IMPORT SITES ==="
  grep -r "from.*common.legacy\|import.*legacy\|ong_fd_components\|wellpath3D" \
    src/ tests/ --include="*.py" -l | xargs cat

  echo "=== SYMBOL LIST ==="
  cat /tmp/legacy_symbols.txt
} | gemini -p "
Given the legacy source files and all files that import or reference them:
1. For each top-level symbol in the SYMBOL LIST, classify it:
   - DEAD: no reference found in any non-legacy file
   - MIGRATED: re-exported via a shim/init, callers use the new path
   - LIVE: directly imported and used by non-legacy callers
2. List DEAD symbols first (deletion candidates), then MIGRATED (safe to remove after
   shim cleanup), then LIVE (must keep or redirect)
3. For LIVE symbols: list the files that call them
4. Estimate: what % of each legacy file can be deleted?" -y \
> specs/wrk/WRK-661/legacy-dead-code-report.md
```

### Phase 2 — Validate dead symbols with grep (5 min)

For each symbol marked DEAD, confirm with a targeted grep:
```bash
while IFS= read -r sym; do
  count=$(grep -r "$sym" src/ tests/ --include="*.py" \
    --exclude-dir="legacy" | wc -l)
  echo "$count $sym"
done < <(grep "^DEAD" specs/wrk/WRK-661/legacy-dead-code-report.md | awk '{print $2}')
```
Any symbol with count > 0 is a false-positive — demote to LIVE.

### Phase 3 — Capture follow-on WRKs (5 min)

- If DEAD symbols ≥ 20% of file: create WRK for deletion
- If MIGRATED symbols dominant: create WRK for shim cleanup + legacy deletion
- Record counts in report summary

## Acceptance Criteria

- [ ] `specs/wrk/WRK-661/legacy-dead-code-report.md` with DEAD/MIGRATED/LIVE
  classification for every top-level symbol in both legacy files
- [ ] Grep validation confirms no false-positive DEADs
- [ ] Deletion % estimate per file
- [ ] Follow-on WRK items created if deletion is viable (>20% DEAD)

## Why

Legacy files are the #1 source of maintenance debt — they accumulate dead code that
blocks refactoring and inflates test surface. Gemini reads the full caller graph in
one shot, avoiding the incremental grep-and-miss approach.

## Agentic AI Horizon

High fit: static analysis + call-site mapping requires no runtime execution.
Gemini's large context holds both legacy files and all their callers simultaneously.
