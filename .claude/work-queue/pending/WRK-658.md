---
id: WRK-658
title: "fix(workflow): enforce gate+logging contract for every AI agent"
status: pending
route: C
priority: high
complexity: medium
compound: false
created_at: 2026-03-01T12:00:00Z
target_repos:
  - workspace-hub
commit:
spec_ref:
related:
  - WRK-624
  - WRK-655
  - WRK-656
  - WRK-657
blocked_by: []
synced_to: []
plan_reviewed: false
plan_approved: false
percent_complete: 0
brochure_status: n/a
computer: ace-linux-1
execution_workstations: [ace-linux-1]
plan_workstations: [ace-linux-1]
provider: claude
orchestrator: claude
cross_review: pending
---
# fix(workflow): enforce gate + logging contract for every AI agent

## Problem

The gate contract and validator we recently drove through WRK-656/657 live inside `CLAUDE.md` and the Claude wrappers, so Codex/Gemini (and future agents) can still bypass `/work run`, skip user approval, and move straight to execution. We need a universal enforcement point that records start/finish, runs `verify-gate-evidence.py`, and captures the same plan/cross-review/TDD/legal evidence for every agent.

## What

Create a parallel-agent-level workflow guard that:

1. logs the start and completion of every agent-driven WRK run (session/work/plan/execute/review) so the lifecycle can be replayed for missing stages
2. runs `scripts/work-queue/verify-gate-evidence.py` (and the NO_OUTPUT policy) before any claim or close, regardless of whether Claude, Codex, or Gemini executes
3. exercises the flow in a sandbox (real or created WRK) using Claude, Codex, and Gemini so we prove the guard works across providers
4. updates the gate-contract docs/templates (CLAUDE.md, orchestrator-gate-contract.md, template) so the rule applies to all agents

Scope is intentionally broad so that the enforcement is mirrored across the ecosystem and the logs act as proofs when stages are missed.

## Plan

### Phase 1 — Logging guard

- extend the `/work run` wrappers (`scripts/agents/session.sh`, `scripts/agents/work.sh`, `scripts/agents/plan.sh`, `scripts/agents/execute.sh`, `scripts/agents/review.sh`) to append start/stop entries (timestamp, provider, action, validator result) to `.claude/work-queue/logs/` before each gate and after completion
- ensure `claim-item.sh`/`close-item.sh` log the validator outcome so the entry can be replayed

### Phase 2 — Cross-agent validation

- adapt the validator (verify-gate-evidence.py) to read the log entries, verify user-approved plan+review artifacts exist for every agent, and fail when `user_html_blocker` or plan approval is missing
- document the fail-fast contract in the docs so every agent knows that missing log/plan entries block claims

### Phase 3 — Sandbox rehearsal

- pick or create a sandbox WRK (e.g., WRK-659) and run it end-to-end using Claude, Codex, and Gemini sequentially with the new logging/validator guard
- capture the cross-review artifacts/test evidence and deposit them in the assets folder (review outputs, plan HTML, legal scan, etc.) so the log proves the gate worked
- update the docs with the sandbox results as an example of the contract working across agents

## Acceptance Criteria
- [ ] `/work run` wrappers log start/stop with provider and gate outcome, and the logs are stored under `.claude/work-queue/logs/` for every agent run
- [ ] `claim-item.sh`, `close-item.sh`, and `verify-gate-evidence.py` rely on those logs and refuse to proceed without valid gate evidence (including user-approved plan HTML)
- [ ] The sandbox run shows Claude/Codex/Gemini obey the gate (plan review + cross-review + TDD + legal + user approval) and the logs/validator pass
- [ ] Documentation (CLAUDE.md/orchestrator-gate-contract.md) explicitly states the contract applies to all AI agents and references the new logging artifacts

## Evidence
- `.claude/work-queue/logs/WRK-XYZ-*.log` with start/finish/op outcomes
- validator invocation log with per-gate status
- updated docs and sandbox review artifacts

## Outcome

Every agent that touches a WRK is now bound to the same gate + logging contract, with filterable logs for audit and sandbox-proven compliance that can be replayed if a stage ever goes missing.
