---
id: WRK-101
title: "Add mesh decimation/coarsening to mesh-utilities skill"
status: pending
priority: low
complexity: medium
created_at: 2026-02-05T07:00:00Z
updated_at: 2026-02-05T07:00:00Z
target_repos:
  - digitalmodel
commit:
spec_ref:
related: [WRK-031]
blocked_by: []
synced_to: []
---

# Add Mesh Decimation/Coarsening to Mesh-Utilities

## What
Implement proper mesh decimation using either:
1. VTK's `vtkQuadricClustering` via PyVista
2. GMSH remeshing with larger element size
3. Custom vertex clustering algorithm

Currently only simple panel-skip coarsening is available.

## Why
The mesh-utilities skill needs robust coarsening for:
- Quick preliminary solver runs with reduced mesh
- Convergence studies (varying panel count)
- Reducing overly-detailed CAD exports

## Acceptance Criteria
- [ ] Implement at least one robust decimation method
- [ ] Preserve mesh topology (no holes introduced)
- [ ] Preserve quality (aspect ratio not degraded significantly)
- [ ] Add `coarsen_mesh()` function to mesh-utilities skill
- [ ] Test: reduce 5000-panel mesh to 500 panels with quality check
- [ ] Update skill documentation with usage examples

## Plan

### Phase 0: Existing Code Inventory and Gap Analysis

**Current mesh decimation implementation (vertex clustering):**
- `src/digitalmodel/hydrodynamics/hull_library/coarsen_mesh.py` -- 249 lines, implements:
  - `coarsen_mesh(mesh: PanelMesh, target_panels: int, preserve_features: bool) -> PanelMesh`
  - Vertex clustering algorithm: divide bounding box into 3D grid, assign vertices to cells, compute cell centroids, remap panels, remove degenerates
  - Feature-preserving mode: `_compute_feature_subdivision()` uses panel normal variance to identify high-curvature regions, subdivides cells (factor 2 or 3) in curved areas
  - Imports `PanelMesh` and `MeshFormat` from `hydrodynamics/bemrosetta/models/mesh_models.py`
  - **Limitation:** Simple vertex clustering -- no edge collapse, no quadric error metrics, no topology preservation guarantee

**Related mesh infrastructure:**
- `src/digitalmodel/hydrodynamics/bemrosetta/models/mesh_models.py` -- `PanelMesh` dataclass (vertices, panels, normals, areas, centers, bounding_box), `MeshQualityReport` with quality scoring
- `src/digitalmodel/hydrodynamics/bemrosetta/mesh/mesh_handler.py` -- `BaseMeshHandler` with `validate_mesh()`, aspect ratio checks, normal consistency, degenerate panel detection; `convert_mesh()` between GDF/DAT/STL
- `src/digitalmodel/hydrodynamics/hull_library/mesh_generator.py` -- `HullMeshGenerator` produces `PanelMesh` from hull profiles; includes degenerate panel removal and vertex deduplication
- `src/digitalmodel/hydrodynamics/diffraction/mesh_pipeline.py` -- `MeshPipeline` for loading, converting, validating meshes across solver formats
- `src/digitalmodel/solvers/gmsh_meshing/` -- `GMSHMeshGenerator` for 3D FE meshing (boxes, cylinders, STL remeshing); `MeshQualityAnalyzer` for tetrahedral quality; export to VTK/MSH
- `.claude/agents/gmsh/utilities/mesh_generator.py`, `mesh_metrics.py` -- agent-level GMSH utilities

**Software availability:**
- PyVista/VTK: NOT installed (`ModuleNotFoundError` for both)
- GMSH: NOT installed (`ModuleNotFoundError`)
- numpy/scipy: available (scipy used in `mesh_handler.py` for KDTree duplicate detection)

**Existing tests:**
- `tests/hydrodynamics/hull_library/test_mesh_generator.py` -- tests `HullMeshGenerator` with box hull profiles
- `tests/hydrodynamics/bemrosetta/test_mesh.py` -- mesh handler tests
- `tests/hydrodynamics/diffraction/test_mesh_pipeline.py` -- pipeline tests
- `tests/solvers/gmsh_meshing/test_gmsh_unit.py`, `test_gmsh_cli.py` -- GMSH tests

**Gap identified:** The current `coarsen_mesh()` uses simple vertex clustering which can introduce topology holes, degrade aspect ratios, and does not guarantee a specific output panel count. The WRK-101 requirement is for robust decimation that preserves topology and quality.

### Phase 1: Implement Quadric Error Metrics (QEM) Decimation -- Pure NumPy

**Target path:** `src/digitalmodel/hydrodynamics/hull_library/decimation.py`

This is the primary deliverable: a proper mesh decimation algorithm that does not require VTK or GMSH.

1. `decimation.py` -- implements the Garland-Heckbert QEM algorithm:
   - `decimate_mesh(mesh: PanelMesh, target_panels: int, preserve_boundary: bool = True) -> PanelMesh`
   - Algorithm steps:
     a. Compute a quadric error matrix (Q) for each vertex from its incident panel planes
     b. For each edge, compute the optimal contraction target and cost = v^T * (Q1+Q2) * v
     c. Build a min-heap of edge contractions sorted by cost
     d. Iteratively collapse the lowest-cost edge: merge vertices, update adjacency, recompute affected edge costs
     e. Stop when panel count reaches target
     f. If `preserve_boundary`: assign high cost to boundary edges (edges with only one adjacent panel)
   - Uses only numpy and standard library (heapq for priority queue)
   - Returns a new `PanelMesh` with reduced panel count

2. Data structures in `decimation.py`:
   - `_VertexQuadric` -- 4x4 symmetric matrix per vertex
   - `_EdgeHeap` -- min-heap of `(cost, edge_id, v1, v2, optimal_position)` tuples
   - `_HalfEdgeMesh` -- lightweight half-edge adjacency structure built from `PanelMesh.panels`

**Why QEM over alternatives:**
- VTK `vtkQuadricClustering` requires VTK installation (not available)
- GMSH remeshing requires GMSH installation (not available)
- QEM is the gold standard for mesh simplification: O(n log n), preserves geometry, handles boundaries
- Pure numpy implementation avoids external dependencies

**Tests:** `tests/hydrodynamics/hull_library/test_decimation.py`
- `test_decimate_box_mesh_preserves_vertex_count_bound` -- reduce a known box mesh, verify output panel count is within 10% of target
- `test_decimate_no_holes_introduced` -- verify the Euler characteristic is preserved (V - E + F = 2 for closed mesh)
- `test_decimate_preserves_bounding_box` -- bounding box of decimated mesh stays within tolerance of original
- `test_decimate_aspect_ratio_not_degraded` -- max aspect ratio of output mesh is within 2x of input
- `test_decimate_5000_to_500_panels` -- acceptance criterion: reduce 5000-panel mesh to 500 panels with quality check
- `test_decimate_noop_when_target_exceeds_current` -- if target >= current panels, return input unchanged
- `test_decimate_boundary_preservation` -- for open meshes (e.g., half-hull with symmetry plane), boundary edges are not collapsed

### Phase 2: Optional VTK/PyVista Backend

**Target path:** `src/digitalmodel/hydrodynamics/hull_library/decimation_vtk.py`

1. `decimation_vtk.py` -- VTK-backed decimation (optional, gated behind import check):
   - `decimate_mesh_vtk(mesh: PanelMesh, target_reduction: float, method: str = "quadric_clustering") -> PanelMesh`
   - Methods:
     a. `quadric_clustering` -- `pyvista.PolyData.decimate()` wrapping `vtkQuadricDecimation`
     b. `pro_decimate` -- `vtkDecimatePro` for faster but lower-quality decimation
   - Conversion helpers:
     a. `panel_mesh_to_pyvista(mesh: PanelMesh) -> pyvista.PolyData`
     b. `pyvista_to_panel_mesh(polydata: pyvista.PolyData, name: str) -> PanelMesh`
   - Graceful import: `try: import pyvista; VTK_AVAILABLE = True except: VTK_AVAILABLE = False`

**Tests:** `tests/hydrodynamics/hull_library/test_decimation_vtk.py`
- All tests decorated with `@pytest.mark.skipif(not VTK_AVAILABLE, reason="PyVista/VTK not installed")`
- Mirror the same quality assertions as Phase 1 tests

### Phase 3: Optional GMSH Remeshing Backend

**Target path:** `src/digitalmodel/hydrodynamics/hull_library/decimation_gmsh.py`

1. `decimation_gmsh.py` -- GMSH-backed surface remeshing (optional):
   - `remesh_coarsen(mesh: PanelMesh, target_element_size: float) -> PanelMesh`
   - Algorithm: export PanelMesh to temporary STL, load into GMSH, set target element size, regenerate surface mesh, extract and convert back to PanelMesh
   - Uses `solvers/gmsh_meshing/mesh_generator.py` pattern for GMSH initialization and cleanup
   - Gated behind `GMSH_AVAILABLE` flag (same pattern as `solvers/gmsh_meshing/mesh_generator.py` line 16)

**Tests:** `tests/hydrodynamics/hull_library/test_decimation_gmsh.py`
- Decorated with `@pytest.mark.skipif(not GMSH_AVAILABLE, reason="GMSH not installed")`

### Phase 4: Unified `coarsen_mesh()` API and Strategy Selection

**Target path:** Modify `src/digitalmodel/hydrodynamics/hull_library/coarsen_mesh.py`

1. Refactor existing `coarsen_mesh()` to become a dispatcher:
   ```python
   def coarsen_mesh(
       mesh: PanelMesh,
       target_panels: int,
       method: str = "auto",  # "auto", "qem", "vertex_clustering", "vtk", "gmsh"
       preserve_features: bool = True,
   ) -> PanelMesh:
   ```
   - `"auto"`: try QEM first (always available), fall back to vertex clustering for very large meshes (>50K panels) where QEM is slow
   - `"qem"`: use Phase 1 QEM decimation
   - `"vertex_clustering"`: use existing algorithm (renamed to `_vertex_clustering_coarsen()`)
   - `"vtk"`: use Phase 2 VTK backend (raise if unavailable)
   - `"gmsh"`: use Phase 3 GMSH backend (raise if unavailable)

2. Preserve backward compatibility: existing callers of `coarsen_mesh(mesh, target_panels, preserve_features=True)` continue to work unchanged (the new `method` parameter has a default)

3. Add `DecimationResult` dataclass:
   ```python
   @dataclass
   class DecimationResult:
       mesh: PanelMesh
       method_used: str
       input_panels: int
       output_panels: int
       quality_before: MeshQualityReport
       quality_after: MeshQualityReport
       elapsed_seconds: float
   ```

**Tests:** `tests/hydrodynamics/hull_library/test_coarsen_mesh.py`
- Test dispatcher routing for each method string
- Test `"auto"` selects QEM
- Test backward compatibility with existing call signature

### Phase 5: Mesh Quality Validation Integration

1. Wire `BaseMeshHandler.validate_mesh()` from `bemrosetta/mesh/mesh_handler.py` into the decimation pipeline:
   - Before decimation: capture quality baseline
   - After decimation: validate output quality
   - Emit warnings if quality degraded beyond thresholds (aspect_ratio_max > 10, degenerate panels > 0)
2. Add quality-constrained decimation option:
   ```python
   def coarsen_mesh(
       ...,
       max_aspect_ratio: float | None = None,  # stop if exceeded
   )
   ```

### Phase 6: Update Skill Documentation

**Target:** `.claude/agents/gmsh/utilities/mesh_metrics.py` and any skill documentation referencing mesh coarsening.

1. Add `coarsen_mesh()` usage examples to docstrings
2. Document the three backend options and when to use each
3. Add example for convergence study workflow:
   ```python
   for target in [5000, 2500, 1000, 500]:
       coarsened = coarsen_mesh(fine_mesh, target, method="qem")
       # run solver with coarsened mesh
   ```

### Risks and Mitigations

| Risk | Mitigation |
|------|-----------|
| QEM algorithm complexity for quad meshes | PanelMesh uses quads (4 vertices per panel); split quads to tris internally for edge collapse, then optionally merge back to quads |
| Performance on large meshes (>50K panels) | Use numpy vectorization for quadric computation; heap operations are O(log n); vertex clustering fallback for very large meshes |
| Topology holes from aggressive decimation | Euler characteristic check after decimation; boundary edge preservation; stop early if topology violation detected |
| No VTK/GMSH available for testing | Primary implementation (QEM) has zero external dependencies; VTK/GMSH backends are optional enhancements with skip-marked tests |
| Breaking existing `coarsen_mesh()` callers | New `method` parameter has default value `"auto"`; existing 3-argument call signature preserved; renamed internal function with underscore prefix |

### Dependency Summary

- **Required:** `numpy` (already available), `heapq` (stdlib)
- **Optional:** `pyvista` (VTK backend), `gmsh` (GMSH backend), `scipy` (quality analysis KDTree, already used)
- **Internal:** `hydrodynamics/bemrosetta/models/mesh_models.py` (PanelMesh), `hydrodynamics/bemrosetta/mesh/mesh_handler.py` (quality validation)

### Test Generation Helper

To create the 5000-panel test mesh without external dependencies:
```python
def make_sphere_mesh(n_panels: int) -> PanelMesh:
    """Generate a UV-sphere PanelMesh with approximately n_panels quad panels."""
    # Use numpy to generate sphere vertices via latitude/longitude grid
    # This provides a known-good test mesh with varying curvature
```

This helper goes into `tests/hydrodynamics/hull_library/conftest.py` or a shared fixture module.

---
*Source: Enhancement for mesh-utilities skill*
