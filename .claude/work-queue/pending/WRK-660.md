---
id: WRK-660
title: "analysis(assetutilities): test coverage gap audit — 5 untested modules via Gemini"
status: pending
route: B
priority: high
complexity: medium
compound: false
created_at: 2026-03-01T00:00:00Z
target_repos:
  - assetutilities
commit:
spec_ref:
related:
  - WRK-350
  - WRK-351
blocked_by: []
synced_to: []
plan_reviewed: false
plan_approved: false
percent_complete: 0
brochure_status: n/a
computer: ace-linux-1
provider: gemini
orchestrator: gemini
cross_review: pending
---

# analysis(assetutilities): Test Coverage Gap Audit — 5 Untested Modules

## What

Five assetutilities modules have zero test files:
`base_configs`, `calculations`, `devtools`, `tools`, `units`.

Use Gemini to read all source files for each module plus the existing test files
(for format/pattern reference) in a single pass and produce a concrete, copy-pasteable
test plan with specific test function signatures and edge cases.

## Plan

### Phase 1 — Collect source and reference tests (5 min)

```bash
cd assetutilities

# Dump the 5 untested modules
find src/assetutilities/base_configs \
     src/assetutilities/calculations \
     src/assetutilities/devtools \
     src/assetutilities/tools \
     src/assetutilities/units \
     -name "*.py" | sort | xargs cat

# Dump 3 existing well-tested modules as pattern reference
cat tests/common/test_data.py tests/common/test_utilities.py 2>/dev/null | head -300
```

Pipe both into Gemini:

```bash
{
  echo "=== SOURCE FILES ==="
  find src/assetutilities/{base_configs,calculations,devtools,tools,units} \
    -name "*.py" | sort | xargs cat
  echo "=== EXISTING TEST PATTERN REFERENCE ==="
  find tests/ -name "test_*.py" | head -3 | xargs cat
} | gemini -p "
For each of the 5 modules (base_configs, calculations, devtools, tools, units):
1. List every public function/class that needs a test
2. For each, write the test function signature and docstring:
   def test_<function>_<scenario>_<expected>():
3. Include at least one happy path, one edge case, and one error case per function
4. Output as ready-to-paste pytest code blocks, one section per module
5. Use the reference test pattern for imports and fixture style" -y \
> specs/wrk/WRK-660/test-coverage-gap-plan.md
```

### Phase 2 — Validate against existing tests (5 min)

Check that none of the proposed test functions already exist:
```bash
grep -r "def test_" tests/ --include="*.py" | \
  awk -F: '{print $NF}' | sort > /tmp/existing_tests.txt
grep "def test_" specs/wrk/WRK-660/test-coverage-gap-plan.md | \
  sort > /tmp/proposed_tests.txt
comm -13 /tmp/existing_tests.txt /tmp/proposed_tests.txt
```

### Phase 3 — Scaffold test files (10 min)

Create the 5 empty test files with module-level docstrings:
```
tests/base_configs/test_base_configs.py
tests/calculations/test_calculations.py
tests/devtools/test_devtools.py
tests/tools/test_tools.py
tests/units/test_units.py
```
Copy the relevant pytest code blocks from the plan into each file.
Run `python -m pytest tests/{base_configs,calculations,devtools,tools,units}/ -v`
to confirm they collect (even if most are `pass` stubs).

## Acceptance Criteria

- [ ] `specs/wrk/WRK-660/test-coverage-gap-plan.md` exists with pytest code blocks
  for all 5 modules
- [ ] Each module has ≥3 test functions (happy + edge + error)
- [ ] 5 test files scaffolded and collect without errors
- [ ] No overlap with existing test functions (comm check passes)
- [ ] Legal scan passes

## Why

assetutilities is a shared dependency for digitalmodel, worldenergydata, and assethold.
Untested utilities propagate silent bugs across all three. Gemini's large context lets
it read the full source of all 5 modules simultaneously and produce consistent test
patterns without losing context between modules.

## Agentic AI Horizon

High fit: Gemini reads code, writes test stubs. No external dependencies or licenses.
Pure analysis + code generation within a well-defined boundary.
