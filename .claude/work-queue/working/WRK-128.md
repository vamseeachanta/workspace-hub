---
id: WRK-128
title: "Map object property routing from engineering specs to OrcaFlex objects"
status: working
priority: high
complexity: complex
compound: false
created_at: 2026-02-11T18:00:00Z
target_repos:
  - digitalmodel
commit:
spec_ref:
related: [WRK-127, WRK-032, WRK-064, WRK-095, WRK-121, WRK-125, WRK-129]
blocked_by: []
synced_to: []
plan: inline
plan_reviewed: true
plan_approved: true
percent_complete: 0
brochure_status:
tags: [property-routing, orcaflex, pipeline, mooring, vessel, spec-to-model, data-pipeline]
---

# Map Object Property Routing from Engineering Specs to OrcaFlex Objects

## What
Define and implement the full property routing path from high-level engineering specifications (mooring spec, vessel spec, pipeline spec, etc.) all the way to concrete OrcaFlex model objects ready for analysis. For each object type (pipeline, mooring lines, vessels, risers, etc.), document and codify how properties flow from the source spec through transformations into the final OrcaFlex object.

## Why
- Currently the path from "I have a mooring system specification" to "I have an OrcaFlex mooring line object" is not explicitly mapped
- Engineers need to understand what properties are needed at each stage and how they transform
- A clear routing map enables automated spec-to-model pipelines, reduces manual setup errors
- Makes the framework extensible — adding a new object type means defining its routing, not ad-hoc scripting

## Acceptance Criteria
- [ ] All relevant OrcaFlex object types inventoried with their required properties
- [ ] Property source mapping documented for each object type
- [ ] Transformation chain from spec to OrcaFlex object defined and documented
- [ ] Routing implemented for at least 3 key object types (vessel, mooring line, pipeline)
- [ ] End-to-end walkthrough examples demonstrating spec to OrcaFlex object
- [ ] Validation tests confirming property fidelity through the routing chain
- [ ] Architecture documented for extensibility (adding new object types)

## Plan

**Target**: `src/digitalmodel/solvers/orcaflex/property_routing/` (new module) + `docs/modules/orcaflex/property_routing/`

### Existing Assets (reuse)
- `src/.../modular_generator/schema/` — ProjectInputSpec (root), GenericModel, PipelineSpec, RiserSpec
- `src/.../modular_generator/builders/` — 15+ builders (generic, pipeline, riser) with `_PRIORITY_KEYS`, `_SKIP_*_KEYS`
- `src/.../modular_generator/extractor.py` — MonolithicExtractor (reverse route: OrcaFlex to spec)
- `data/hull_library/catalog/hull_panel_catalog.yaml` — hull meshes (23 entries)
- WRK-121 s7 models — real-world examples of jumper, installation, mooring, vessel rigging chains
- WRK-095 unit tracking — complements routing with unit provenance

### Phase 1 — OrcaFlex Object Type Inventory
- Enumerate all OrcaFlex object types used across all models: General, Environment, Vessel, VesselType, Line, LineType, 3DBuoy, 6DBuoy, Shape, Winch, Link, Constraint, ClumpType, BendStiffener, FrictionCoefficients, RayleighDamping
- For each type: list all settable properties (from OrcFxAPI docs + SaveData output inspection)
- Classify properties: required vs optional, mode-dependent (dormant), numeric vs enum vs string
- Output: `docs/modules/orcaflex/property_routing/object_inventory.yaml`

### Phase 2 — Property Source Mapping (3 Key Routes)
Route each property to its engineering source:

**Route A: Pipeline**
- Engineering input: OD, WT, grade, coating thickness, contents density, route (KP to depth), seabed stiffness
- Transformations: pipe stress to line type (EI, EA, w_air, w_water), coating to additional line type sections
- OrcaFlex objects: LineType (N sections), Line (route + seabed), Environment (depth + current)

**Route B: Mooring Line**
- Engineering input: line composition (chain-wire-chain), segment lengths, anchor positions, fairlead positions, pretension
- Transformations: chain grade to MBL to EA, wire catalog to properties, catenary equilibrium to line lengths
- OrcaFlex objects: LineType per segment, Line with connection endpoints, Winch (for pretension)

**Route C: Vessel**
- Engineering input: principal dimensions (L/B/D/T), displacement, GM, hull form, RAO data source
- Transformations: hull catalog to mesh file, DiffractionSpec to RAO solve to vessel type data
- OrcaFlex objects: VesselType (RAO data, added mass, damping), Vessel (position, heading)

### Phase 3 — Routing Implementation
- `property_router.py` — Base class with `route(source_spec) -> Dict[str, Dict]` producing OrcaFlex YAML sections
- `pipeline_router.py` — Implements Route A
- `mooring_router.py` — Implements Route B
- `vessel_router.py` — Implements Route C
- Each router: validates input, applies transformations, outputs OrcaFlex-ready property dicts
- **Builder integration**: Routers produce `generic` section dicts compatible with existing `GenericModelBuilder`. They do NOT replace builders — they sit upstream, translating engineering specs into the `ProjectInputSpec` format that builders already consume. This avoids maintaining two parallel pipelines.
- Integration flow: `EngineeringSpec → Router → ProjectInputSpec (generic field) → GenericModelBuilder → OrcaFlex YAML`

### Phase 4 — Walkthrough Examples
- For each route: documented end-to-end trace from engineering values to OrcaFlex model
- Example: "6in SCR from wellhead to FPSO" -> RiserSpec -> modular generation -> converging statics
- Example: "3-leg mooring with drag anchors" -> MooringSpec -> LineTypes + Lines + Winches
- Example: "FPSO with RAOs from hull catalog" -> VesselSpec -> DiffractionSpec -> VesselType

### Phase 5 — Validation & Tests
- Round-trip: spec -> route -> build OrcaFlex model -> extract -> compare with original spec
- Property coverage: verify all routed properties appear in final model
- Unit tests: each router with known inputs -> expected OrcaFlex outputs
- Integration: route + generate + statics convergence for each walkthrough example

---
*Source: route object properties (pipeline, mooring lines, etc.) all the way from how we can get to a mooring or vessel spec all the way to an orcaflex object for analysis*
