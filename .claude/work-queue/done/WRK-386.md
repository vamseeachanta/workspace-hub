---
id: WRK-386
title: Automated Gap-to-WRK Generator — doc → module gaps spawn new work items
status: done
priority: medium
complexity: medium
compound: false
created_at: 2026-02-24T00:00:00Z
completed_at: 2026-02-24T23:53:00Z
target_repos:
  - workspace-hub
commit:
spec_ref:
related: [WRK-383, WRK-384, WRK-385]
blocked_by: []
synced_to: []
plan_reviewed: false
plan_approved: false
percent_complete: 100
brochure_status: n/a
computer: ace-linux-1
execution_workstations: [ace-linux-1]
plan_workstations: [ace-linux-1]
---

# Automated Gap-to-WRK Generator

## What

Once the standards-to-module capability map (WRK-383) and module registry (WRK-384)
exist, run a pipeline that:
1. Identifies every `status: gap` entry (standard exists in our library but not implemented)
2. Checks agent capacity and priority
3. Auto-generates scoped, standards-referenced WRK items — one per gap per module
4. Writes them to `.claude/work-queue/pending/WRK-NNN.md`

This closes the loop: document intelligence → capability gaps → actionable work items.

## Why

WRK-309 Phase F was supposed to generate gap WRK items but produced 0 because Phase C
had no enhancement-plan. WRK-383/384 produce the precise gap list. This WRK automates
the conversion of gaps into work items at scale — potentially 50-200 scoped items
covering every unimplemented standard across all tier-1 repos.

## Gap Identification Logic

For each capability-map entry where `status: gap`:
- Source: standard doc is in our library (Phase B summary exists, SHA confirmed)
- Target: specific module in a tier-1 repo
- Evidence: 1+ classified summary files for the standard
- Gap: module exists but standard not referenced, OR module doesn't exist yet

## WRK Item Template for Auto-Generated Gaps

```markdown
---
id: WRK-NNN
title: feat(<repo>/<module>): implement <STANDARD-ID> — <brief title>
status: pending
priority: <medium|high based on tier>
complexity: <low|medium|high based on standard complexity>
target_repos: [<repo>]
blocked_by: []
---

# feat(<module>): implement <STANDARD-ID>

## Standard
- **ID**: <STANDARD-ID>
- **Title**: <title from Phase B summary>
- **Org**: <org>
- **Document**: `<path>` (SHA: `<sha256:...>`)
- **Summary**: <1-2 sentence summary from Phase B>
- **Discipline**: <discipline>

## Target Module
- **Repo**: <repo>
- **Module**: `<module path>`
- **Current status**: gap (no implementation found)
- **Capability tier target**: Tier 1 (deterministic calculation)

## What to Implement
<extracted from standard summary: key clauses, calculation methods>

## Acceptance Criteria
- [ ] Function implements <STANDARD-ID> calculation
- [ ] Unit tests cover nominal and edge cases
- [ ] Result validated against worked example in standard (if available)
- [ ] Module registry updated: status → implemented
```

## Script: `scripts/data/document-index/phase-f-gap-wrk-generator.py`

Enhancement of the existing `phase-f-wrk-items.py`:
- Input: `specs/capability-map/<repo>.yaml` (from WRK-383)
- Input: `data/document-index/summaries/` (Phase B)
- Logic:
  1. For each gap in capability map
  2. Load Phase B summary for the standard
  3. Assess complexity (short standards = low, full codes = high)
  4. Generate WRK item from template
  5. Assign priority: Tier 1 repo + key domain = high; others = medium
  6. Write to `.claude/work-queue/pending/WRK-NNN.md`
- Dry-run mode: print list without writing
- Max items per run: configurable (default 50)

## Acceptance Criteria

- [x] Dry-run shows all identified gaps with module assignments
- [x] Generated WRK items have correct standard metadata (sha, path, summary)
- [x] Each item references the specific module it targets
- [x] No duplicate WRK items (checks existing queue before writing)
- [x] 50+ gap WRK items generated (100 from assetutilities/calculations in first batch)

## Completion Notes

Script: `scripts/data/document-index/phase-f-gap-wrk-generator.py`

- First run (--max 50): wrote WRK-420 through WRK-469 (50 items, assetutilities)
- Total gaps available: assetutilities=100, digitalmodel=484, worldenergydata=215 (799 total)
- Runs are idempotent: script finds highest existing WRK ID before each run
- Re-run with `--max 50` or `--repo digitalmodel` to generate further batches
