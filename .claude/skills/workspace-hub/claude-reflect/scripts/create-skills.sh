#!/usr/bin/env bash
# create-skills.sh - Auto-skill creation from patterns
# Part of RAGS loop: STORE phase with action

set -euo pipefail

STATE_DIR="${HOME}/.claude/state"
PATTERNS_DIR="${STATE_DIR}/patterns"
SKILLS_BASE="${SKILLS_BASE:-/mnt/github/workspace-hub/.claude/skills}"
SKILLS_OUTPUT="${SKILLS_BASE}/workspace-hub/auto-generated"
MEMORY_DIR="${HOME}/.claude/memory/patterns"

mkdir -p "$SKILLS_OUTPUT" "$MEMORY_DIR"

# Scoring thresholds
THRESHOLD_CREATE=0.8    # Create new skill
THRESHOLD_ENHANCE=0.6   # Enhance existing
DRY_RUN="${DRY_RUN:-false}"

# Get latest pattern file
PATTERN_FILE="${1:-$(ls -t "$PATTERNS_DIR"/patterns_*.json 2>/dev/null | head -1)}"

if [[ ! -f "$PATTERN_FILE" ]]; then
    echo "Error: No pattern file found" >&2
    exit 1
fi

echo "Processing patterns from: $PATTERN_FILE"
echo "Dry run: $DRY_RUN"
echo ""

# Score a pattern (0.0 - 1.0)
score_pattern() {
    local repos="$1"
    local count="$2"
    local message="$3"

    # Frequency score (based on occurrence count)
    local freq_score=$(echo "scale=2; if ($count > 10) 1.0 else $count / 10" | bc)

    # Cross-repo score (based on number of repos)
    local repo_score=$(echo "scale=2; if ($repos > 10) 1.0 else $repos / 10" | bc)

    # Complexity score (longer messages = more complex patterns)
    local msg_len=${#message}
    local complexity_score=$(echo "scale=2; if ($msg_len > 50) 0.8 else $msg_len / 62.5" | bc)

    # Time savings estimate (cross-repo = high savings)
    local savings_score=$(echo "scale=2; if ($repos > 5) 0.9 else $repos / 5.5" | bc)

    # Weighted final score
    local final=$(echo "scale=2; ($freq_score * 0.3) + ($repo_score * 0.3) + ($complexity_score * 0.2) + ($savings_score * 0.2)" | bc)

    echo "$final"
}

# Create a skill from a pattern
create_skill() {
    local pattern_name="$1"
    local pattern_desc="$2"
    local repos="$3"
    local score="$4"

    # Generate skill name from pattern
    local skill_name=$(echo "$pattern_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-30)
    local skill_dir="${SKILLS_OUTPUT}/${skill_name}"

    if [[ "$DRY_RUN" == "true" ]]; then
        echo "[DRY RUN] Would create skill: $skill_name (score: $score)"
        return
    fi

    mkdir -p "$skill_dir"

    cat > "${skill_dir}/SKILL.md" << EOF
---
name: ${skill_name}
description: Auto-generated skill from cross-repo pattern - ${pattern_desc}
version: 1.0.0
category: workspace-hub/auto-generated
type: skill
auto_generated: true
source_pattern: "${pattern_name}"
creation_date: $(date -Iseconds)
score: ${score}
source_repos:
$(echo "$repos" | tr ',' '\n' | sed 's/^/  - /')
---

# ${pattern_name}

> Auto-generated skill from recurring cross-repository pattern

## Pattern Details

**Description:** ${pattern_desc}

**Score:** ${score}

**Detected in repositories:**
$(echo "$repos" | tr ',' '\n' | sed 's/^/- /')

## When to Use

This skill was auto-generated because the pattern "${pattern_name}" was detected across multiple repositories. Use this when performing similar operations.

## Implementation

Based on the detected pattern, this skill captures:

1. The workflow or code pattern identified
2. Common implementation approach
3. Cross-repository applicability

## Examples

*Examples extracted from commit history:*

\`\`\`
Pattern: ${pattern_name}
Repos: ${repos}
\`\`\`

---

*Auto-generated by claude-reflect on $(date "+%Y-%m-%d")*
EOF

    echo "Created skill: $skill_dir"
}

# Store pattern in memory (for patterns below threshold)
store_learning() {
    local pattern="$1"
    local repos="$2"
    local score="$3"

    local memory_file="${MEMORY_DIR}/learnings.yaml"

    if [[ "$DRY_RUN" == "true" ]]; then
        echo "[DRY RUN] Would store learning: $pattern (score: $score)"
        return
    fi

    # Append to learnings file
    cat >> "$memory_file" << EOF

- pattern: "${pattern}"
  repos: "${repos}"
  score: ${score}
  date: $(date -Iseconds)
EOF

    echo "Stored learning: $pattern"
}

# Process patterns
echo "=== Processing Cross-Repo Patterns ==="
echo ""

SKILLS_CREATED=0
SKILLS_ENHANCED=0
LEARNINGS_STORED=0

# Extract and process each cross-repo pattern
jq -r '.cross_repo_patterns[] | "\(.message)|\(.repos | join(","))|\(.count)"' "$PATTERN_FILE" | while IFS='|' read -r message repos count; do
    repo_count=$(echo "$repos" | tr ',' '\n' | wc -l)
    score=$(score_pattern "$repo_count" "$count" "$message")

    # Truncate message for display
    short_msg="${message:0:50}"

    echo "Pattern: \"$short_msg...\""
    echo "  Repos: $repo_count | Count: $count | Score: $score"

    # Determine action based on score
    if (( $(echo "$score >= $THRESHOLD_CREATE" | bc -l) )); then
        echo "  Action: CREATE SKILL"
        create_skill "$message" "Pattern detected in $repo_count repositories" "$repos" "$score"
        ((SKILLS_CREATED++)) || true
    elif (( $(echo "$score >= $THRESHOLD_ENHANCE" | bc -l) )); then
        echo "  Action: ENHANCE EXISTING"
        # For now, store as learning for manual enhancement
        store_learning "$message" "$repos" "$score"
        ((SKILLS_ENHANCED++)) || true
    else
        echo "  Action: STORE LEARNING"
        store_learning "$message" "$repos" "$score"
        ((LEARNINGS_STORED++)) || true
    fi
    echo ""
done

# Update state file
STATE_FILE="${STATE_DIR}/reflect-state.yaml"
if [[ -f "$STATE_FILE" ]] && [[ "$DRY_RUN" != "true" ]]; then
    cat >> "$STATE_FILE" << EOF
last_skill_creation: $(date -Iseconds)
actions_taken:
  skills_created: $SKILLS_CREATED
  skills_enhanced: $SKILLS_ENHANCED
  learnings_stored: $LEARNINGS_STORED
EOF
fi

echo "=== Summary ==="
echo "Skills Created: $SKILLS_CREATED"
echo "Skills Enhanced: $SKILLS_ENHANCED"
echo "Learnings Stored: $LEARNINGS_STORED"
