---
name: orcaflex-visualization
description: Generate visualizations from OrcaFlex and OrcaWave simulations using
  the shared OrcFxAPI — model views (SaveModelView), time series plots, range graphs,
  and interactive HTML reports. Covers both .dat/.sim (OrcaFlex) and .owd (OrcaWave)
  files via the same API surface.
version: 1.2.0
updated: 2026-02-23
category: offshore-engineering
triggers:
- visualization
- plot results
- model view
- mesh view
- schematic
- time series plot
- range graph
- animation
- HTML report
- interactive plot
- orcawave mesh screenshot
- diffraction mesh view
capabilities: []
requires: []
see_also:
- orcawave-analysis
- orcawave-mesh-generation
---
# OrcaFlex Visualization Skill

Generate comprehensive visualizations from OrcaFlex simulations including model views, plots, and interactive HTML reports.

## Version Metadata

```yaml
version: 1.2.0
python_min_version: '3.10'
dependencies:
  orcaflex-modeling: '>=2.0.0,<3.0.0'
  orcaflex-post-processing: '>=1.0.0,<2.0.0'
orcaflex_version: '>=11.0'
compatibility:
  tested_python:
  - '3.10'
  - '3.11'
  - '3.12'
  - '3.13'
  os:
  - Windows
  - Linux
  - macOS
```

## Changelog

### [1.2.0] - 2026-02-23

**Added:**
- `save_orcawave_views(owd_path, out_dir)` — primary public helper in `mesh_capture.py`
- `BenchmarkPlotter.save_mesh_views(fig, out_dir)` — exports 3 PNG views via Plotly Kaleido
- `BenchmarkPlotter._build_panel_mesh3d_fig()` — returns `go.Figure` (refactored from HTML wrapper)
- Static PNG images now embedded base64 above Plotly widget in mesh schematic section
- OrcaWave Schematic Capture section documenting 3-tier approach (see below)

### [1.1.0] - 2026-02-23

**Added:**
- OrcaWave section documenting `OrcFxAPI.Diffraction` class (distinct from `Model`)
- Verified finding: `Diffraction` loads both `.owd`/`.owr`; has NO `SaveModelView`
- OrcaWave file format note: binary header `\x08OrcaWave` — not loadable by `Model()`
- `SaveSymmetrisedBodyMesh(symmetry, tol, path)` — verified working with `PanelMeshSymmetry.XZ`
- `SaveAutoGeneratedFreeSurfacePanelledZoneMesh(path)` — available when model has FS zone
- GDF format primer and `gdf_to_mesh3d()` Plotly rendering helper
- Plotly 3-view camera preset table (elevation/plan/perspective) for Figure 30 style
- Codebase implementation index including `qtf_postprocessing.py` `panelGeometry` usage

### [1.0.0] - 2026-01-17

**Added:**
- Initial release with OPP visualization integration
- Model view image export
- Interactive Plotly plots
- Time series and range graph visualization
- HTML report generation

## When to Use

- Generating model view images for reports
- Creating time series plots of simulation results
- Visualizing range graphs along line arc lengths
- Building interactive HTML dashboards
- Comparing multiple simulations visually
- Animating simulation results
- Capturing diffraction mesh screenshots for OrcaWave validation reports

## OrcaWave Compatibility (Shared OrcFxAPI)

Both OrcaFlex and OrcaWave are Orcina products sharing the same `OrcFxAPI` module.
**However, they use different classes with different capabilities:**

| Class | Loads | `SaveModelView`? | Mesh export? |
|-------|-------|-----------------|-------------|
| `OrcFxAPI.Model` | `.dat`, `.sim` (OrcaFlex) | **YES** | via `panelGeometry` |
| `OrcFxAPI.Diffraction` | `.owd`, `.owr` (OrcaWave) | **NO** | YES — GDF exporters |

> **Key finding (verified 2026-02-23):** `Diffraction` loads both `.owd` (input) and
> `.owr` (results) via `LoadData()`/`LoadResults()`. It has no `SaveModelView`.
> OrcaWave files have the binary header `\x08OrcaWave` — they are NOT loadable by
> `OrcFxAPI.Model()`. Direct UI screenshots must be taken manually from OrcaWave GUI.

### OrcaWave Schematic Capture (Static PNG)

Three approaches exist, ranked by reliability. The Plotly+Kaleido path is the
**primary** method — it is headless, cross-platform, and requires no OrcaWave GUI.

| Tier | Method | Reliability | Notes |
|------|--------|-------------|-------|
| 1 (primary) | **Plotly + Kaleido** | High | Headless; uses `panelGeometry`; no OrcaWave open |
| 2 (secondary) | `OrcaWaveScreenCapture` (win32gui/pyautogui) | Low | Fragile; Windows-only; OrcaWave must be open |
| 3 (tertiary) | GDF → `OrcFxAPI.Model.SaveModelView()` | Medium | Loses free-surface zone; requires OrcaFlex |

**Primary path — Plotly + Kaleido:**

```python
from digitalmodel.hydrodynamics.diffraction.mesh_capture import save_orcawave_views
from pathlib import Path

paths = save_orcawave_views(
    owd_path=Path("model.owr"),
    out_dir=Path("output/mesh_views"),
)
# → output/mesh_views/mesh_perspective.png
# → output/mesh_views/mesh_plan.png
# → output/mesh_views/mesh_elevation.png
```

`save_orcawave_views()` internally calls:
1. `OrcFxAPI.Diffraction(str(owd_path))` → reads `.panelGeometry`
2. `BenchmarkPlotter._build_panel_mesh3d_fig()` → builds `go.Figure`
3. `BenchmarkPlotter.save_mesh_views(fig, out_dir)` → writes 3 PNGs via kaleido

Kaleido must be installed: `uv add kaleido` (already in `pyproject.toml`).

**Secondary path — OrcaWaveScreenCapture (fragile):**

Located at `src/.../orcawave/vision/screen_capture.py`. Requires OrcaWave GUI
open and the correct window in focus. Use only as last resort on Windows where
kaleido is unavailable.

**Tertiary path — GDF → OrcaFlex SaveModelView():**

Export GDF via `Diffraction.SaveSymmetrisedBodyMesh()`, load into an OrcaFlex
`Model()`, call `model.SaveModelView(filepath, vp)`. Limitation: the free-surface
panel zone is not part of the OrcaFlex model and will not appear in the view.

### OrcaWave Mesh Export via Diffraction

`OrcFxAPI.Diffraction` exposes mesh export methods that output GDF geometry files.
These can be parsed and rendered programmatically (Plotly 3D mesh → Figure 30 style).

```python
import OrcFxAPI as ofx

d = ofx.Diffraction()
d.LoadData("model.owd")           # or d.LoadResults("model.owr")

# Body mesh (GDF format) — corresponds to red mesh in Figure 30
d.SaveSymmetrisedBodyMesh(
    ofx.PanelMeshSymmetry.none,   # none=full, XZ=XZ-symmetric, YZ, XZYZ
    0.001,                        # clipping tolerance (metres)
    "body_mesh.gdf"
)

# Auto-generated free surface panelled zone (GDF) — blue mesh in Figure 30
# Only available when model has FreeSurfacePanelledZone enabled
d.SaveAutoGeneratedFreeSurfacePanelledZoneMesh("freesurface_mesh.gdf")

# Auto-generated control surface (GDF) — requires control surface in model
d.SaveAutoGeneratedControlSurfaceMesh("control_surface.gdf")
```

**PanelMeshSymmetry enum values and integers:**

| Value | Integer | Meaning |
|-------|---------|---------|
| `none` | 0 | No symmetry — only valid if model has no intrinsic symmetry |
| `XZ` | 1 | XZ-plane symmetry ← most common (verified working for BMC case) |
| `YZ` | 2 | YZ-plane symmetry |
| `XZYZ` | 3 | Both XZ and YZ symmetry |

> **Important**: pass the enum constant, not the integer. For models with intrinsic
> symmetry (e.g. XZ), `PanelMeshSymmetry.none` fails with error 49 "Invalid symmetry".
> Match the symmetry type to what the model was built with.

**GDF format (WAMIT panel mesh):**
```
<header line>
<ulen> <grav>
<isx> <isy>
<npan>
x1 y1 z1  x2 y2 z2  x3 y3 z3  x4 y4 z4   <- one quad panel per line
...
```

### Programmatic Mesh Rendering (Plotly — Figure 30 style)

Since `SaveModelView` is not available, render mesh from GDF/panelGeometry data:

```python
import numpy as np
import plotly.graph_objects as go

def gdf_to_mesh3d(gdf_path, color="red"):
    """Parse WAMIT GDF file and return Plotly Mesh3d trace."""
    panels = []
    with open(gdf_path) as f:
        lines = f.readlines()
    # Skip header lines until we get numeric data
    for line in lines[4:]:
        parts = [float(x) for x in line.split() if x.strip()]
        if len(parts) == 12:          # 4 corners × 3 coords
            panels.append(np.array(parts).reshape(4, 3))
    if not panels:
        return None
    verts = np.vstack(panels)
    n = len(panels)
    i = list(range(0, 4*n, 4))
    j = list(range(1, 4*n, 4))
    k = list(range(2, 4*n, 4))
    return go.Mesh3d(x=verts[:,0], y=verts[:,1], z=verts[:,2],
                     i=i, j=j, k=k, color=color, opacity=0.7)
```

For the **elevation/plan/perspective** 3-view layout matching Figure 30, generate
3 separate Plotly figures with `scene.camera` positioned accordingly:

| View | `eye` vector | matches |
|------|-------------|---------|
| Elevation (a) | `(0, -2, 0)` | side profile looking in +Y |
| Plan (b) | `(0, 0, 2)` | top-down looking in -Z |
| Perspective (c) | `(1.2, -1.2, 0.8)` | isometric 3D |

### OrcaFlex: Canonical SaveModelView Pattern

```python
import OrcFxAPI as ofx

def save_model_view(model: ofx.Model, filepath: str, **view_params):
    """Save OrcaFlex model screenshot. NOT available for OrcaWave."""
    vp = model.defaultViewParameters
    for k, v in view_params.items():
        if hasattr(vp, k):
            setattr(vp, k, v)
    model.SaveModelView(str(filepath), vp)

m = ofx.Model()
m.LoadData("model.dat")
m.CalculateStatics()
save_model_view(m, "view.bmp",
    ViewAzimuth=315, ViewElevation=30,   # perspective
    FileWidth=960, FileHeight=720, BackgroundColour=0)
```

### Existing Codebase Implementations

| Script / Module | Coverage | Notes |
|----------------|----------|-------|
| `scripts/capture_riser_views.py` | Minimal `SaveModelView` | OrcaFlex `.dat`; verified |
| `src/.../orcaflex/pipeline_schematic.py` | Multi-view YAML config | `OrcaFlexViewCapture` class |
| `src/.../orcaflex/opp_visualization.py` | Batch parallel (30 workers) | `save_all_views()` |
| `scripts/benchmark/qtf_postprocessing.py` | `panelGeometry` 3D scatter | OrcaWave body panels, used in benchmark report |
| `scripts/build_sme_report.py` | `img_to_base64()` | HTML embedding of BMP/PNG/JPG |

For HTML embedding use `img_to_base64()` from `scripts/build_sme_report.py` —
converts BMP/PNG/JPG to `data:image/...;base64` URI for inline `<img>` tags.

### panelGeometry Structured Array Schema

`d.panelGeometry` returns a numpy structured array (one record per panel):

```
dtype fields:
  objectId          int32       body object index
  objectName        str (U31)   body name e.g. 'test101 bottom mounted cylinder'
  vertices          float64 (4,3) four quad panel corners [x, y, z] metres
  centroid          float64 (3)  panel centroid [x, y, z]
  normal            float64 (3)  outward unit normal vector
  area              float64      panel area (m²)
  meshFilePanelIndex int32       index into source mesh file
  panelType         int32        panel type code
```

**Usage for Plotly Mesh3d rendering (body panels):**

```python
import numpy as np
import plotly.graph_objects as go

pg = d.panelGeometry         # structured array, shape (n_panels,)
verts = pg['vertices']       # (n_panels, 4, 3)

# Triangulate quads → 2 triangles each for Mesh3d
x, y, z, i_, j_, k_ = [], [], [], [], [], []
base = 0
for v in verts:              # v shape (4, 3)
    x.extend(v[:, 0]); y.extend(v[:, 1]); z.extend(v[:, 2])
    i_.extend([base, base + 2])
    j_.extend([base + 1, base + 3])
    k_.extend([base + 2, base])
    base += 4

body_mesh = go.Mesh3d(
    x=x, y=y, z=z, i=i_, j=j_, k=k_,
    color='red', opacity=0.7, name='Body mesh',
)
```

## Visualization Types

### Model Views

| View Type | Description |
|-----------|-------------|
| Plan View | Top-down view (XY plane) |
| Elevation View | Side view (XZ or YZ plane) |
| 3D View | Isometric perspective |
| Object View | Centered on specific object |

### Plot Types

| Plot | Description | Library |
|------|-------------|---------|
| Time Series | Value vs time | Plotly |
| Range Graph | Value vs arc length | Plotly |
| Histogram | Distribution of values | Plotly |
| Polar | Directional responses | Plotly |
| Heatmap | Multi-variable correlation | Plotly |

## Configuration

### Basic Visualization Configuration

```yaml
# configs/visualization_config.yml

visualization:
  # Model views
  views:
    enabled: true
    output_directory: "images/"
    format: "jpg"
    quality: 95

    view_list:
      - name: "plan_view"
        type: "plan"
        width: 1920
        height: 1080

      - name: "elevation_view"
        type: "elevation"
        plane: "XZ"
        width: 1920
        height: 1080

      - name: "3d_view"
        type: "3d"
        azimuth: 45
        elevation: 30
        width: 1920
        height: 1080

  # Time series plots
  time_series:
    enabled: true
    output_directory: "plots/time_series/"
    format: "html"   # Interactive Plotly

    variables:
      - object: "Mooring_Line_1"
        variable: "Effective Tension"
        label: "Line 1 Tension (kN)"

      - object: "Vessel"
        variable: "Heave"
        label: "Vessel Heave (m)"

  # Range graphs
  range_graphs:
    enabled: true
    output_directory: "plots/range_graphs/"

    objects:
      - name: "Riser"
        variables:
          - "Effective Tension"
          - "Curvature"
          - "Bend Moment"

  # HTML report
  report:
    enabled: true
    output_file: "reports/analysis_report.html"
    title: "OrcaFlex Analysis Report"
    include_summary: true
    include_plots: true
    include_tables: true
```

### Advanced Visualization Configuration

```yaml
# configs/visualization_advanced.yml

visualization:
  # View styling
  view_style:
    background_color: "white"
    sea_surface:
      visible: true
      style: "transparent"
      color: [0, 100, 200, 128]  # RGBA
    seabed:
      visible: true
      style: "solid"
      color: [139, 119, 101]
    objects:
      line_width: 2
      vessel_color: [200, 0, 0]

  # Multiple viewpoints
  viewpoints:
    - name: "bow_view"
      centre_on: "Vessel"
      direction: [1, 0, 0]
      distance: 500

    - name: "stern_view"
      centre_on: "Vessel"
      direction: [-1, 0, 0]
      distance: 500

    - name: "touchdown"
      position: [800, 0, -1450]
      target: "Riser"
      arc_length: 1200

  # Plot styling
  plot_style:
    template: "plotly_white"
    font_family: "Arial"
    font_size: 14
    title_font_size: 18
    color_palette: "viridis"

  # Comparison plots
  comparison:
    enabled: true
    simulations:
      - path: "results/baseline.sim"
        label: "Baseline"
        color: "blue"
      - path: "results/modified.sim"
        label: "Modified"
        color: "red"

    variables:
      - object: "Line_1"
        variable: "Effective Tension"
```

## Python API

### Model View Generation

```python
from digitalmodel.orcaflex.opp_visualization import OPPVisualization
from pathlib import Path

def generate_model_views(
    sim_file: str,
    output_dir: str,
    views: list = None
) -> list:
    """
    Generate model view images from simulation.

    Args:
        sim_file: Path to .sim file
        output_dir: Output directory for images
        views: List of view configurations

    Returns:
        List of generated image paths
    """
    visualizer = OPPVisualization()

    # Default views
    if views is None:
        views = [
            {
                "name": "plan",
                "type": "plan",
                "width": 1920,
                "height": 1080
            },
            {
                "name": "elevation",
                "type": "elevation",
                "plane": "XZ",
                "width": 1920,
                "height": 1080
            },
            {
                "name": "3d",
                "type": "3d",
                "azimuth": 45,
                "elevation": 30,
                "width": 1920,
                "height": 1080
            }
        ]

    # Generate views
    image_paths = visualizer.save_views_for_files(
        sim_files=[sim_file],
        output_directory=Path(output_dir),
        view_parameters=views
    )

    return image_paths

# Example usage
images = generate_model_views(
    sim_file="results/mooring_analysis.sim",
    output_dir="images/",
    views=[
        {"name": "overview", "type": "3d", "azimuth": 45, "elevation": 30}
    ]
)

for img in images:
    print(f"Generated: {img}")
```

### Time Series Plotting

```python
import OrcFxAPI
import plotly.graph_objects as go
from plotly.subplots import make_subplots

def plot_time_series(
    sim_file: str,
    variables: list,
    output_file: str = None
) -> go.Figure:
    """
    Create interactive time series plot.

    Args:
        sim_file: Path to .sim file
        variables: List of {object, variable, label}
        output_file: Optional output HTML file

    Returns:
        Plotly figure
    """
    model = OrcFxAPI.Model(sim_file)

    # Create subplots
    fig = make_subplots(
        rows=len(variables),
        cols=1,
        shared_xaxes=True,
        vertical_spacing=0.05,
        subplot_titles=[v.get("label", v["variable"]) for v in variables]
    )

    for i, var_config in enumerate(variables, 1):
        obj = model[var_config["object"]]
        var_name = var_config["variable"]

        # Get time history
        times = obj.SampleTimes(period=None)
        values = obj.TimeHistory(var_name, period=None)

        # Add trace
        fig.add_trace(
            go.Scatter(
                x=times,
                y=values,
                name=var_config.get("label", var_name),
                mode="lines",
                line=dict(width=1)
            ),
            row=i,
            col=1
        )

        # Add statistics annotation
        stats_text = f"Max: {max(values):.2f}, Min: {min(values):.2f}, Mean: {sum(values)/len(values):.2f}"
        fig.add_annotation(
            text=stats_text,
            xref=f"x{i}", yref=f"y{i}",
            x=0.02, y=0.98,
            xanchor="left", yanchor="top",
            showarrow=False,
            bgcolor="white",
            row=i, col=1
        )

    # Update layout
    fig.update_layout(
        height=300 * len(variables),
        showlegend=False,
        title="Time Series Analysis"
    )

    fig.update_xaxes(title_text="Time (s)", row=len(variables), col=1)

    # Save if requested
    if output_file:
        fig.write_html(output_file)
        print(f"Saved: {output_file}")

    return fig

# Example usage
variables = [
    {"object": "Mooring_Line_1", "variable": "Effective Tension", "label": "Line 1 Tension (kN)"},
    {"object": "Vessel", "variable": "Heave", "label": "Vessel Heave (m)"},
    {"object": "Vessel", "variable": "Pitch", "label": "Vessel Pitch (deg)"}
]

fig = plot_time_series(
    sim_file="results/analysis.sim",
    variables=variables,
    output_file="plots/time_series.html"
)
```

### Range Graph Plotting

```python
import OrcFxAPI
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np

def plot_range_graph(
    sim_file: str,
    object_name: str,
    variables: list,
    output_file: str = None
) -> go.Figure:
    """
    Create range graph (min/max/mean vs arc length).

    Args:
        sim_file: Path to .sim file
        object_name: Line object name
        variables: List of variable names
        output_file: Optional output HTML file

    Returns:
        Plotly figure
    """
    model = OrcFxAPI.Model(sim_file)
    obj = model[object_name]

    # Get arc lengths
    arc_lengths = obj.RangeGraphXaxis(period=None)

    # Create subplots
    fig = make_subplots(
        rows=len(variables),
        cols=1,
        shared_xaxes=True,
        vertical_spacing=0.05,
        subplot_titles=variables
    )

    for i, var_name in enumerate(variables, 1):
        # Get range graph data
        min_values = obj.RangeGraph(var_name, period=None, arclengthRange=None).Min
        max_values = obj.RangeGraph(var_name, period=None, arclengthRange=None).Max
        mean_values = obj.RangeGraph(var_name, period=None, arclengthRange=None).Mean

        # Add traces
        fig.add_trace(
            go.Scatter(
                x=arc_lengths, y=max_values,
                name=f"{var_name} Max",
                line=dict(color="red", width=2),
                legendgroup=f"var{i}"
            ),
            row=i, col=1
        )

        fig.add_trace(
            go.Scatter(
                x=arc_lengths, y=mean_values,
                name=f"{var_name} Mean",
                line=dict(color="green", width=2),
                legendgroup=f"var{i}"
            ),
            row=i, col=1
        )

        fig.add_trace(
            go.Scatter(
                x=arc_lengths, y=min_values,
                name=f"{var_name} Min",
                line=dict(color="blue", width=2),
                legendgroup=f"var{i}"
            ),
            row=i, col=1
        )

        # Fill between min and max
        fig.add_trace(
            go.Scatter(
                x=list(arc_lengths) + list(arc_lengths)[::-1],
                y=list(max_values) + list(min_values)[::-1],
                fill="toself",
                fillcolor="rgba(128,128,128,0.2)",
                line=dict(color="rgba(255,255,255,0)"),
                showlegend=False
            ),
            row=i, col=1
        )

    # Update layout
    fig.update_layout(
        height=350 * len(variables),
        title=f"Range Graph: {object_name}"
    )

    fig.update_xaxes(title_text="Arc Length (m)", row=len(variables), col=1)

    if output_file:
        fig.write_html(output_file)

    return fig

# Example usage
fig = plot_range_graph(
    sim_file="results/riser_analysis.sim",
    object_name="Riser",
    variables=["Effective Tension", "Curvature", "Bend Moment"],
    output_file="plots/riser_range_graph.html"
)
```

### Polar Plot for Directional Analysis

```python
import plotly.graph_objects as go
import numpy as np

def create_polar_plot(
    headings: list,
    values: list,
    title: str = "Directional Response",
    output_file: str = None
) -> go.Figure:
    """
    Create polar plot for directional analysis.

    Args:
        headings: List of heading angles (degrees)
        values: List of response values
        title: Plot title
        output_file: Optional output HTML file

    Returns:
        Plotly figure
    """
    # Close the polar plot
    headings_closed = list(headings) + [headings[0]]
    values_closed = list(values) + [values[0]]

    fig = go.Figure()

    # Add response trace
    fig.add_trace(go.Scatterpolar(
        r=values_closed,
        theta=headings_closed,
        mode="lines+markers",
        name="Response",
        line=dict(color="blue", width=2),
        marker=dict(size=8)
    ))

    # Add limit circle if provided
    limit_value = max(values) * 1.1
    fig.add_trace(go.Scatterpolar(
        r=[limit_value] * (len(headings_closed)),
        theta=headings_closed,
        mode="lines",
        name="Limit",
        line=dict(color="red", width=2, dash="dash")
    ))

    fig.update_layout(
        title=title,
        polar=dict(
            radialaxis=dict(
                visible=True,
                range=[0, max(values) * 1.2]
            ),
            angularaxis=dict(
                direction="clockwise",
                rotation=90  # 0° at top
            )
        ),
        showlegend=True
    )

    if output_file:
        fig.write_html(output_file)

    return fig

# Example: Operability envelope
headings = list(range(0, 360, 15))
max_tensions = [2450, 2380, 2250, 2180, 2120, 2150, 2200, 2280,
                2350, 2400, 2420, 2380, 2320, 2250, 2180, 2120,
                2100, 2150, 2200, 2280, 2350, 2400, 2440, 2450]

fig = create_polar_plot(
    headings=headings,
    values=max_tensions,
    title="Maximum Tension vs Heading",
    output_file="plots/polar_envelope.html"
)
```

### HTML Report Generation

```python
from pathlib import Path
import plotly.graph_objects as go
from datetime import datetime

def generate_html_report(
    title: str,
    sim_file: str,
    figures: list,
    summary_data: dict,
    output_file: str
) -> str:
    """
    Generate comprehensive HTML report.

    Args:
        title: Report title
        sim_file: Source simulation file
        figures: List of Plotly figures
        summary_data: Summary statistics dictionary
        output_file: Output HTML file path

    Returns:
        Path to generated report
    """
    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>{title}</title>
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
        <style>
            body {{
                font-family: Arial, sans-serif;
                margin: 40px;
                background-color: #f5f5f5;
            }}
            h1 {{
                color: #333;
                border-bottom: 2px solid #007bff;
                padding-bottom: 10px;
            }}
            h2 {{
                color: #555;
                margin-top: 30px;
            }}
            .summary-table {{
                border-collapse: collapse;
                width: 100%;
                max-width: 800px;
                margin: 20px 0;
            }}
            .summary-table th, .summary-table td {{
                border: 1px solid #ddd;
                padding: 12px;
                text-align: left;
            }}
            .summary-table th {{
                background-color: #007bff;
                color: white;
            }}
            .summary-table tr:nth-child(even) {{
                background-color: #f2f2f2;
            }}
            .plot-container {{
                background: white;
                padding: 20px;
                margin: 20px 0;
                border-radius: 5px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }}
            .metadata {{
                color: #777;
                font-size: 0.9em;
                margin-bottom: 20px;
            }}
        </style>
    </head>
    <body>
        <h1>{title}</h1>
        <div class="metadata">
            <p>Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
            <p>Source: {sim_file}</p>
        </div>

        <h2>Summary Statistics</h2>
        <table class="summary-table">
            <tr>
                <th>Parameter</th>
                <th>Value</th>
                <th>Units</th>
            </tr>
    """

    # Add summary rows
    for key, value in summary_data.items():
        if isinstance(value, dict):
            html_content += f"""
            <tr>
                <td>{key}</td>
                <td>{value.get('value', 'N/A')}</td>
                <td>{value.get('units', '')}</td>
            </tr>
            """
        else:
            html_content += f"""
            <tr>
                <td>{key}</td>
                <td>{value}</td>
                <td></td>
            </tr>
            """

    html_content += """
        </table>

        <h2>Analysis Plots</h2>
    """

    # Add plots
    for i, fig in enumerate(figures):
        plot_div = fig.to_html(full_html=False, include_plotlyjs=False)
        html_content += f"""
        <div class="plot-container">
            {plot_div}
        </div>
        """

    html_content += """
    </body>
    </html>
    """

    # Write file
    with open(output_file, "w") as f:
        f.write(html_content)

    return output_file

# Example usage
summary = {
    "Maximum Tension": {"value": 2450.5, "units": "kN"},
    "Maximum Heave": {"value": 5.2, "units": "m"},
    "Simulation Duration": {"value": 10800, "units": "s"},
    "Water Depth": {"value": 1500, "units": "m"}
}

# Create figures
time_fig = plot_time_series(sim_file, variables)
range_fig = plot_range_graph(sim_file, "Riser", ["Effective Tension"])
polar_fig = create_polar_plot(headings, tensions)

# Generate report
report_path = generate_html_report(
    title="Mooring Analysis Report",
    sim_file="results/mooring_analysis.sim",
    figures=[time_fig, range_fig, polar_fig],
    summary_data=summary,
    output_file="reports/analysis_report.html"
)

print(f"Report generated: {report_path}")
```

### Parallel View Generation

```python
from digitalmodel.orcaflex.opp_visualization import OPPVisualization
from concurrent.futures import ProcessPoolExecutor
from pathlib import Path

def generate_views_parallel(
    sim_files: list,
    output_dir: str,
    views: list,
    max_workers: int = 4
) -> list:
    """
    Generate model views in parallel.

    Args:
        sim_files: List of .sim file paths
        output_dir: Output directory
        views: View configurations
        max_workers: Parallel workers

    Returns:
        List of all generated image paths
    """
    visualizer = OPPVisualization()

    all_images = visualizer._save_views_parallel(
        sim_files=sim_files,
        output_directory=Path(output_dir),
        view_parameters=views,
        max_workers=max_workers
    )

    return all_images

# Example: Generate views for all simulations
sim_files = list(Path("results/.sim/").glob("*.sim"))

views = [
    {"name": "plan", "type": "plan"},
    {"name": "3d", "type": "3d", "azimuth": 45, "elevation": 30}
]

images = generate_views_parallel(
    sim_files=sim_files,
    output_dir="images/",
    views=views,
    max_workers=4
)

print(f"Generated {len(images)} images")
```

## Output Formats

### Image Outputs

| Format | Extension | Use Case |
|--------|-----------|----------|
| JPEG | .jpg | General purpose, reports |
| PNG | .png | Transparency, high quality |
| SVG | .svg | Scalable, publications |

### Interactive Outputs

| Format | Extension | Features |
|--------|-----------|----------|
| HTML | .html | Hover, zoom, pan, export |
| JSON | .json | Plotly figure data |

## Best Practices

### Model Views

1. **Resolution** - Use 1920x1080 for reports
2. **Consistent views** - Same viewpoint across simulations
3. **Styling** - Consistent colors and backgrounds
4. **Labeling** - Include object labels in views

### Interactive Plots

1. **Plotly** - Use for all web-based visualization
2. **Subplots** - Group related variables
3. **Hover info** - Include key statistics
4. **Export** - Provide download options

### HTML Reports

1. **Structure** - Clear sections and navigation
2. **Summary first** - Key findings up front
3. **Interactive plots** - Embed Plotly figures
4. **Metadata** - Include source and timestamps

## Error Handling

```python
try:
    images = generate_model_views(sim_file, output_dir)
except OrcFxAPI.OrcaFlexError as e:
    print(f"OrcaFlex error: {e}")
    print("Check simulation file is valid")

except FileNotFoundError:
    print("Simulation file not found")
```

## Related Skills

- [orcaflex-post-processing](../orcaflex-post-processing/SKILL.md) - Data extraction
- [orcaflex-operability](../orcaflex-operability/SKILL.md) - Envelope visualization
- [orcaflex-results-comparison](../orcaflex-results-comparison/SKILL.md) - Comparison plots
- [orcaflex-extreme-analysis](../orcaflex-extreme-analysis/SKILL.md) - Extreme value plots

## References

- Plotly Python Documentation
- OrcaFlex: Post-Processing Views
- OrcaWave WAMIT Validation Guide (Figure 30 — elevation/plan/perspective mesh views)
- Source: `scripts/capture_riser_views.py` (canonical minimal pattern)
- Source: `src/digitalmodel/solvers/orcaflex/pipeline_schematic.py` (`OrcaFlexViewCapture`)
- Source: `src/digitalmodel/solvers/orcaflex/opp_visualization.py` (batch parallel)
- Source: `scripts/build_sme_report.py` (`img_to_base64` HTML embedding)
- Source: `src/digitalmodel/solvers/orcaflex/post_results/postProcessPlotting.py`
