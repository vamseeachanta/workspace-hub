{"ts":"2026-02-04T04:52:10.576Z","role":"ai","text":"I'll help you explore the AQWA input file generation pipeline. Let me start by searching and reading the key files.","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:52:10.747Z","role":"ai","text":"[tool:Read]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:52:15.529Z","role":"ai","text":"[tool:Read]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:52:20.011Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:52:24.787Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:52:26.864Z","role":"ai","text":"[tool:Read]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:52:31.761Z","role":"ai","text":"[tool:Glob]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:52:31.671Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:52:54.702Z","role":"ai","text":"[tool:Read]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:52:45.742Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:53:01.157Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:53:14.745Z","role":"ai","text":"Let me now read the converter files and look at spec conversion utilities:","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:53:14.911Z","role":"ai","text":"[tool:Read]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:53:15.505Z","role":"ai","text":"[tool:Read]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:53:23.968Z","role":"ai","text":"[tool:Read]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:53:19.330Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:53:28.237Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:53:35.731Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:53:51.386Z","role":"ai","text":"[tool:Glob]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:00.760Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:10.173Z","role":"ai","text":"Now let me read one of the fixture files to see what a spec looks like:","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:14.481Z","role":"ai","text":"[tool:Read]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:20.658Z","role":"ai","text":"[tool:Grep]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:24.437Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:31.811Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:38.209Z","role":"ai","text":"Let me read the test files to understand how specs are used:","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:40.240Z","role":"ai","text":"[tool:Read]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:44.458Z","role":"ai","text":"[tool:Read]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:44.407Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:54:50.126Z","role":"human","text":"[result]","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
{"ts":"2026-02-04T04:55:50.344Z","role":"ai","text":"Perfect! Now I have a comprehensive understanding of the codebase. Let me provide you with a complete exploration report.\n\n## AQWA Input File Generation Pipeline: Complete Exploration Report\n\n---\n\n### **1. HIGH-LEVEL ARCHITECTURE**\n\nThe pipeline follows a **canonical spec pattern**:\n\n```\nspec.yml (DiffractionSpec)\n         ↓\n    SpecConverter (entry point)\n         ↓\n   AQWABackend OR OrcaWaveBackend\n         ↓\n    Output files (.dat or .yml)\n```\n\n**Key principle**: Solver-agnostic specification → solver-specific input generation\n\n---\n\n### **2. DiffractionSpec SCHEMA** (`input_schemas.py`)\n\nThe spec is a Pydantic v2 model with these key sections:\n\n#### **2.1 Top-Level Structure**\n```python\nclass DiffractionSpec(BaseModel):\n    version: str = \"1.0\"\n    analysis_type: AnalysisType  # enum: diffraction, radiation, etc.\n    \n    # Single body (simple) OR multi-body (list)\n    vessel: Optional[VesselSpec]\n    bodies: Optional[list[BodySpec]]\n    \n    environment: EnvironmentSpec\n    frequencies: FrequencySpec\n    wave_headings: WaveHeadingSpec\n    solver_options: SolverOptions\n    outputs: OutputSpec\n    metadata: MetadataSpec\n```\n\n#### **2.2 Vessel Spec Breakdown**\n\n**VesselGeometry**:\n- `mesh_file`: Path to mesh (relative to spec.yml location)\n- `mesh_format`: enum (gdf, dat, stl, msh, obj, auto)\n- `symmetry`: enum (none, xz, yz, xz+yz)\n- `reference_point`: [x, y, z] in meters\n- `waterline_z`: Z-coordinate of waterline\n- `length_units`: e.g., \"m\"\n\n**VesselInertia**:\n- `mass`: kg (required, > 0)\n- `centre_of_gravity`: [x, y, z]\n- `radii_of_gyration`: [kxx, kyy, kzz] OR\n- `inertia_tensor`: dict with keys {Ixx, Iyy, Izz, Ixy, Ixz, Iyz} (kg.m²)\n\n**VesselSpec** combines:\n- Geometry\n- Inertia\n- Optional: external_stiffness (6x6), external_damping (6x6), fixed_dofs\n\n#### **2.3 Frequencies**\n\n```python\nclass FrequencySpec(BaseModel):\n    input_type: FrequencyInputType  # \"period\" (s) or \"frequency\" (rad/s)\n    values: Optional[list[float]]   # Explicit list OR\n    range: Optional[FrequencyRangeSpec]  # range(start, end, count, distribution)\n```\n\nConversion methods:\n- `to_frequencies_rad_s()` → always returns rad/s\n- `to_periods_s()` → always returns seconds\n\n#### **2.4 Wave Headings**\n\n```python\nclass WaveHeadingSpec(BaseModel):\n    values: Optional[list[float]]      # Explicit degrees OR\n    range: Optional[HeadingRangeSpec]  # range(start=0, end=180, increment=15)\n    symmetry: bool  # If true, exploit 0-180° symmetry\n```\n\n#### **2.5 Solver Options**\n\n```python\nclass SolverOptions(BaseModel):\n    remove_irregular_frequencies: bool = True  # → AQWA \"LHFR\" option\n    qtf_calculation: bool = False               # → AQWA \"MQTF\" option\n    load_rao_method: LoadRAOMethod  # haskind, direct, both\n    precision: SolverPrecision       # single or double\n    qtf_min_frequency: Optional[float]\n    qtf_max_frequency: Optional[float]\n```\n\n#### **2.6 Environment**\n\n```python\nclass EnvironmentSpec(BaseModel):\n    water_depth: float | str  # Numeric OR \"infinite\"/\"inf\"/\"deep\"\n    water_density: float      # kg/m³ (default: 1025)\n    gravity: float            # m/s² (default: 9.80665)\n```\n\n---\n\n### **3. SPEC LOADING & VALIDATION** (`input_schemas.py`)\n\n**Load from YAML**:\n```python\nspec = DiffractionSpec.from_yaml(\"analysis.yml\")\n```\n\n**Key validators**:\n- `vessel` XOR `bodies` (mutually exclusive, one required)\n- Either `values` or `range` for frequencies\n- Either `values` or `range` for headings\n- Mass > 0, CoG has 3 values, etc.\n\n**Access bodies uniformly**:\n```python\nbodies = spec.get_bodies()  # Wraps single vessel into list\n```\n\n---\n\n### **4. AQWA BACKEND** (`aqwa_backend.py`) — SPEC → .DAT FILE\n\n#### **4.1 Entry Points**\n\n```python\nclass AQWABackend:\n    def generate_single(spec, output_dir) → Path  # One .dat file\n    def generate_modular(spec, output_dir) → Path  # One .dat per deck\n```\n\n#### **4.2 Deck Structure** (7 decks total)\n\n| Deck | Purpose | Key Mappings |\n|------|---------|---|\n| **0** | JOB control | `solver_options` → OPTIONS string |\n| **1** | Node coordinates | COOR, NOD5, STRC (mesh placeholder for WRK-060) |\n| **2** | Element connectivity | ELM1, FST (mesh placeholder for WRK-060) |\n| **3** | Mass properties (MATE) | `vessel.inertia.mass` → MATE cards |\n| **4** | Inertia (GEOM/PMAS) | Ixx, Iyy, Izz from inertia spec |\n| **5** | Environment (GLOB) | water_depth, density, gravity |\n| **6** | Frequencies & headings | Frequencies (rad/s → Hz), headings (degrees) |\n\n#### **4.3 Deck 0 — Options Mapping**\n\n```python\ndef _build_options(spec) → str:\n    opts = [\"GOON\"]\n    if spec.solver_options.remove_irregular_frequencies:\n        opts.append(\"LHFR\")\n    if spec.solver_options.qtf_calculation:\n        opts.append(\"MQTF\")\n    opts.extend([\"REST\", \"END\"])\n    return \" \".join(opts)  # e.g., \"GOON LHFR MQTF REST END\"\n```\n\n#### **4.4 Deck 3 — Mass** (`build_deck3`)\n\n```python\nfor idx, body in enumerate(bodies, start=1):\n    mass = body.vessel.inertia.mass\n    # Reference node 98000 = CoG (AQWA convention)\n    card = f\"  {idx}        98000{_fmt_float(mass)}\"  # MATE card\n```\n\n#### **4.4 Deck 4 — Inertia** (`build_deck4`)\n\n```python\nixx, iyy, izz, ixy, ixz, iyz = _compute_inertia(inertia_spec)\n# If explicit inertia_tensor provided: use directly (kg.m²)\n# Else: compute from mass & radii_of_gyration: I = m * k²\ncard = f\"  {idx}PMAS    98000{ixx}{ixy}{ixz}{iyy}{iyz}{izz}\"\n```\n\n#### **4.5 Deck 5 — Environment** (`build_deck5`)\n\n```python\ndepth = _resolve_water_depth(spec.environment.water_depth)\n# \"infinite\"/\"inf\"/\"deep\" → 10000.0 (AQWA deep-water constant)\ncards.append(f\"      DPTH{_fmt_float(depth)}\")\ncards.append(f\"      DENS{_fmt_float(spec.environment.water_density)}\")\ncards.append(f\"      ACCG{gravity:>10g}\")\n```\n\n#### **4.6 Deck 6 — Frequencies & Headings** (`build_deck6`)\n\n```python\n# Frequencies: convert rad/s → Hz for AQWA\nfreqs_rad = spec.frequencies.to_frequencies_rad_s()\nfreqs_hz = [w / (2.0 * math.pi) for w in freqs_rad]\nfor i, freq_hz in enumerate(freqs_hz, start=1):\n    card = f\"      1HRTZ{i:>5d}{i:>5d}{freq_hz:>10g}\"\n\n# Headings in degrees\nheadings = spec.wave_headings.to_heading_list()\nfor i, heading_deg in enumerate(headings, start=1):\n    card = f\"      1DIRN{i:>5d}{i:>5d}{heading_deg:>10g}\"\n```\n\n#### **4.7 Formatting**\n\n```python\ndef _fmt_float(value: float, width=10) -> str:\n    \"\"\"AQWA fixed-width column format\"\"\"\n    if value == 0.0: return f\"{0.0:>{width}.1f}\"\n    abs_val = abs(value)\n    if abs_val >= 1e7 or abs_val < 1e-2:\n        return f\"{value:>{width}.3e}\"  # Scientific\n    if abs_val >= 1000:\n        return f\"{value:>{width}.0f}\"  # Fixed, no decimals\n    return f\"{value:>{width}g}\"        # General format\n```\n\n---\n\n### **5. ORCAWAVE BACKEND** (`orcawave_backend.py`) — SPEC → .YML FILE\n\n#### **5.1 Key Differences from AQWA**\n\n- Output: YAML (not FORTRAN .dat)\n- Unit system: SI with **mass in tonnes** (not kg)\n- Booleans: \"Yes\"/\"No\" strings (not Python bool)\n- Periods in seconds (not frequencies in rad/s)\n- Composite keys with commas for inertia tensors\n\n#### **5.2 Section Structure**\n\n| Section | Mapping |\n|---------|---------|\n| **UnitsSystem** | \"SI\" (fixed) |\n| **General** | SolveType, LoadRAOMethod, QTF settings |\n| **Environment** | WaterDepth, WaterDensity (t/m³), WavesReferredToBy |\n| **Bodies** | Array of body dicts (per BodySpec) |\n| **Frequencies** | PeriodOrFrequency (list, seconds) |\n| **Headings** | WaveHeading (list, degrees) |\n\n#### **5.3 Body Dict Example**\n\n```python\nbody = {\n    \"BodyName\": vessel.name,\n    \"BodyMeshPosition\": [0, 0, 0],\n    \"BodyMeshAttitude\": [0, 0, 0],\n    \"BodyMeshFileName\": \"sample_box.gdf\",\n    \"BodyMeshFormat\": \"Wamit gdf\",  # Maps from enum\n    \"BodyMass\": inertia.mass / 1000.0,  # kg → tonnes\n    \"BodyCentreOfMass\": inertia.centre_of_gravity,\n    \"BodyInertiaTensorRx, BodyInertiaTensorRy, BodyInertiaTensorRz\": \n        [[ixx, ixy, ixz],\n         [ixy, iyy, iyz],\n         [ixz, iyz, izz]],  # 3×3 matrix, in t.m²\n    \"BodyExternalStiffnessMatrixx, ...\": 6×6 matrix,\n    \"BodyExternalDampingMatrixx, ...\": 6×6 matrix,\n    \"BodyConnectionParent\": \"Free\" or parent_name,\n    \"BodyFixedDOFx\": \"Yes\"/\"No\",  # Per DOF\n    ...\n}\n```\n\n#### **5.4 Unit Conversion**\n\n```python\ndef _water_density_tonnes(spec):\n    return spec.environment.water_density / 1000.0  # kg/m³ → t/m³\n\ndef _build_inertia_tensor(body_spec):\n    # If explicit tensor provided: convert kg.m² → t.m²\n    if body_spec.vessel.inertia.inertia_tensor:\n        ixx = t[\"Ixx\"] / 1000.0\n        # etc.\n    # Else compute from mass (tonnes) and radii of gyration\n    mass_t = inertia.mass / 1000.0\n    ixx = mass_t * kxx²\n```\n\n---\n\n### **6. SPEC CONVERTER** (`spec_converter.py`) — UNIFIED ENTRY POINT\n\n```python\nclass SpecConverter:\n    def __init__(self, spec_path: Path):\n        self.spec = DiffractionSpec.from_yaml(spec_path)\n        self.backends = {\n            \"aqwa\": AQWABackend(),\n            \"orcawave\": OrcaWaveBackend(),\n        }\n    \n    def convert(solver=\"aqwa\", format=\"single\", output_dir=Path(\".\")):\n        \"\"\"Generate inputs for one solver.\"\"\"\n        backend = self.backends[solver]\n        if format == \"single\":\n            return backend.generate_single(self.spec, output_dir)\n        return backend.generate_modular(self.spec, output_dir)\n    \n    def convert_all(format=\"single\", output_dir=Path(\".\")):\n        \"\"\"Generate inputs for ALL solvers in parallel-friendly dict.\"\"\"\n        results = {}\n        for name in self.backends:\n            results[name] = self.convert(name, format, output_dir / name)\n        return results  # {\"aqwa\": Path, \"orcawave\": Path}\n    \n    def validate() → list[str]:\n        \"\"\"Return human-readable validation issues.\"\"\"\n        # Checks: mesh files specified, frequencies non-empty, headings non-empty, mass > 0\n```\n\n---\n\n### **7. MESH FILE HANDLING**\n\n**Current status (WRK-060 deferred)**:\n\n1. **Loading**: `spec.get_bodies()[i].vessel.geometry.mesh_file` (string path, relative to spec)\n2. **AQWA output**: Decks 1 & 2 contain only:\n   - `COOR NOD5 STRC {idx}` headers\n   - Comment placeholders: `* Mesh nodes for {name} (mesh file: {path}) — placeholder, see WRK-060`\n3. **OrcaWave output**: `BodyMeshFileName` set to basename (e.g., \"sample_box.gdf\")\n\n**No actual mesh parsing/integration yet** — mesh integration is WRK-060 scope.\n\n---\n\n### **8. WORKING EXAMPLE FROM FIXTURE**\n\n**File**: `spec_ship_raos.yml`\n\n```yaml\nversion: \"1.0\"\nanalysis_type: diffraction\n\nvessel:\n  name: \"Ship_001\"\n  type: \"ship\"\n  geometry:\n    mesh_file: \"../../bemrosetta/fixtures/sample_box.gdf\"\n    mesh_format: gdf\n    symmetry: xz\n    reference_point: [0.0, 0.0, 0.0]\n    waterline_z: 0.0\n    length_units: m\n  inertia:\n    mass: 84387300.0         # kg\n    centre_of_gravity: [0, 0, -1.5]\n    radii_of_gyration: [15, 50, 50]  # kxx, kyy, kzz in m\n\nenvironment:\n  water_depth: 500.0         # meters\n  water_density: 1025.0       # kg/m³\n  gravity: 9.80665            # m/s²\n\nfrequencies:\n  input_type: frequency       # rad/s\n  values: [0.1, 0.2, ..., 1.5]\n\nwave_headings:\n  values: [0, 45, 90, 135, 180]\n  symmetry: true\n\nsolver_options:\n  remove_irregular_frequencies: true  # LHFR\n  qtf_calculation: false\n  load_rao_method: both\n\noutputs:\n  formats: [csv]\n  components: [raos, added_mass, damping]\n\nmetadata:\n  project: \"test_ship_raos\"\n```\n\n**Usage**:\n```python\nfrom digitalmodel.hydrodynamics.diffraction.spec_converter import SpecConverter\n\nconverter = SpecConverter(Path(\"spec_ship_raos.yml\"))\n\n# Single AQWA .dat file\naqwa_path = converter.convert(\"aqwa\", \"single\", Path(\"output/aqwa\"))\n\n# Multiple OrcaWave .yml files\norcawave_dir = converter.convert(\"orcawave\", \"modular\", Path(\"output/orcawave\"))\n\n# Validate\nissues = converter.validate()  # Returns [] if valid\n```\n\n---\n\n### **9. TEST FIXTURES & COVERAGE**\n\n**Available fixtures** (`tests/hydrodynamics/diffraction/fixtures/`):\n1. `spec_ship_raos.yml` — Single-body ship (most common)\n2. `spec_semisub.yml` — Semi-submersible\n3. `spec_fpso_turret.yml` — Multi-body (FPSO + turret)\n\n**Test files** (all use TDD):\n- `test_spec_converter.py` — SpecConverter unit tests\n- `test_aqwa_backend.py` — AQWABackend deck generation\n- `test_orcawave_backend.py` — OrcaWaveBackend YAML generation\n- `test_input_schemas.py` — DiffractionSpec validation\n\n---\n\n### **10. KEY DESIGN PATTERNS**\n\n| Pattern | Example |\n|---------|---------|\n| **Canonical spec** | DiffractionSpec is solver-agnostic superset |\n| **Delegation** | SpecConverter → Backend.generate_* |\n| **Factory methods** | Backend.build_deck{0-6}, _build_*_section |\n| **Conversion functions** | `to_frequencies_rad_s()`, `to_heading_list()` |\n| **Validation chain** | Pydantic validators + `SpecConverter.validate()` semantic checks |\n| **Symmetric access** | `spec.get_bodies()` unifies single-vessel and multi-body |\n\n---\n\n### **11. ANSWERS TO YOUR KEY QUESTIONS**\n\n#### **Q: How does the ship spec (spec_ship_raos.yml) get loaded into DiffractionSpec?**\nA: Via `DiffractionSpec.from_yaml(path)` which:\n1. Parses YAML with `yaml.safe_load()`\n2. Validates against Pydantic v2 model\n3. Raises on validation errors (type/constraint violations)\n\n#### **Q: What does the AQWA backend generate from it (deck structure)?**\nA: Seven FORTRAN-format decks:\n- **Deck 0**: JOB card, TITLE, OPTIONS (GOON, LHFR, MQTF if enabled)\n- **Decks 1–2**: Mesh placeholders (WRK-060)\n- **Deck 3**: MATE cards (mass per body)\n- **Deck 4**: GEOM PMAS cards (inertia tensor)\n- **Deck 5**: GLOB cards (depth, density, gravity)\n- **Deck 6**: HRTZ (frequencies in Hz) + DIRN (headings in °)\n\n#### **Q: What does the OrcaWave backend generate from it?**\nA: OrcaWave YAML with SI units:\n- **Units**: SI (lengths m, mass tonnes, density t/m³)\n- **Bodies**: Array with BodyMeshFileName, BodyMass (tonnes), BodyInertiaTensor (3×3)\n- **Frequencies**: PeriodOrFrequency in seconds\n- **Headings**: WaveHeading in degrees\n- **Solver options**: QTF settings, load RAO method\n\n#### **Q: Is there a mechanism to load a spec and run it through both backends?**\nA: Yes: `SpecConverter.convert_all(format, output_dir)` returns dict with both solver outputs.\n\n#### **Q: What mesh file handling happens during spec loading?**\nA: **None yet** — only path storage. Mesh paths are:\n1. Stored in `vessel.geometry.mesh_file` (relative to spec.yml)\n2. Written to output as placeholders/references\n3. Actual mesh parsing/integration deferred to WRK-060\n\n---\n\n### **12. ABSOLUTE FILE PATHS**\n\nKey files referenced in this exploration:\n\n- `/D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/input_schemas.py` — DiffractionSpec schema\n- `/D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/aqwa_backend.py` — AQWA .dat generator\n- `/D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/orcawave_backend.py` — OrcaWave .yml generator\n- `/D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/spec_converter.py` — Unified entry point\n- `/D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/aqwa_converter.py` — AQWA results parser (inverse pipeline)\n- `/D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/orcawave_converter.py` — OrcaWave results parser\n- `/D:/workspace-hub/digitalmodel/tests/hydrodynamics/diffraction/fixtures/spec_ship_raos.yml` — Working example\n- `/D:/workspace-hub/digitalmodel/tests/hydrodynamics/diffraction/conftest.py` — Test fixtures\n- `/D:/workspace-hub/digitalmodel/tests/hydrodynamics/diffraction/test_spec_converter.py` — Integration tests\n- `/D:/workspace-hub/digitalmodel/tests/hydrodynamics/diffraction/test_aqwa_backend.py` — AQWA generation tests\n\n---\n\nThis exploration covers the complete forward pipeline (spec → solver inputs). The reverse pipeline (solver results → unified schema) is in `aqwa_converter.py` and `orcawave_converter.py` but focuses on **parsing outputs**, not spec loading.","session":"1e35094e-0e12-4613-ae4b-dc93267c84ad"}
