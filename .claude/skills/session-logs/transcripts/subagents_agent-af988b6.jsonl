{"ts":"2026-02-03T19:34:24.618Z","role":"ai","text":"\n\nI'll start by thoroughly exploring the existing codebase to understand the current architecture, patterns, and conventions before designing the implementation plan.","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:34:25.623Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:34:32.295Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:34:32.271Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:34:38.927Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:34:39.500Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:34:46.225Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:34:49.287Z","role":"ai","text":"Now let me read the remaining critical files.","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:34:50.238Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:34:57.267Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:34:57.236Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:04.182Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:04.788Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:11.458Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:15.326Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:22.090Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:22.018Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:28.863Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:29.526Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:36.040Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:40.475Z","role":"ai","text":"Now let me examine the legacy RAO plotting, the OrcaFlex exporter, the test files, and the WRK-029/030 work item specs.","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:41.383Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:48.247Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:48.221Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:54.803Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:35:55.405Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:02.334Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:06.652Z","role":"ai","text":"Now let me look at the WRK-029 and WRK-030 specs, and check the test files for test_orcawave_runner to understand the testing patterns.","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:07.779Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:13.285Z","role":"ai","text":"[tool:Glob]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:13.230Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:15.773Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:16.355Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:23.801Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:28.316Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:35.447Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:35.412Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:45.613Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:49.843Z","role":"ai","text":"Let me also check the input_schemas for the DiffractionSpec.from_yaml method and the get_bodies method, and look at how the existing export code uses Polars (if at all).","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:51.115Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:58.419Z","role":"ai","text":"[tool:Grep]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:36:58.387Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:04.857Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:05.361Z","role":"ai","text":"[tool:Grep]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:12.140Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:15.623Z","role":"ai","text":"Let me look at an existing Polars usage in the project to understand the patterns, and also check the DiffractionSpec for from_yaml and get_bodies.","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:16.676Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:23.607Z","role":"ai","text":"[tool:Grep]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:23.570Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:30.141Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:30.736Z","role":"ai","text":"[tool:Glob]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:35.049Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:39.700Z","role":"ai","text":"[tool:Grep]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:46.109Z","role":"ai","text":"[tool:Grep]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:46.149Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:53.288Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:57.067Z","role":"ai","text":"Now let me check one more file -- the spec_ship_raos fixture to understand the fixture data format, and the existing Plotly usage patterns in the project.","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:37:58.534Z","role":"ai","text":"[tool:Grep]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:38:04.972Z","role":"ai","text":"[tool:Glob]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:38:05.026Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:38:08.653Z","role":"ai","text":"[tool:Read]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:38:14.917Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:38:14.955Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:38:18.514Z","role":"ai","text":"I now have a thorough understanding of the entire codebase. Let me verify one more thing -- the fixtures directory location for the test files.","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:38:19.308Z","role":"ai","text":"[tool:Bash]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:38:20.939Z","role":"ai","text":"[tool:Bash]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:38:22.701Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:38:24.207Z","role":"human","text":"[result]","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
{"ts":"2026-02-03T19:41:06.292Z","role":"ai","text":"I have now explored the entire relevant codebase. Let me compile the comprehensive implementation plan.\n\n---\n\n## WRK-030: OrcaWave Batch Analysis + Postprocessing -- Implementation Plan\n\nThis plan is based on thorough exploration of all existing source files, test files, fixtures, and architectural patterns in the `digitalmodel` project.\n\n---\n\n## 1. THE INTEGRATION GAP (Problem Statement)\n\nThe codebase has two disconnected paths:\n\n**Path A (WRK-029):** `DiffractionSpec` -> `OrcaWaveRunner.run()` -> `RunResult` (file paths + status, NO parsed data)\n\n**Path B (Existing):** Pre-existing `.sim` file -> `OrcaWaveConverter` -> `DiffractionResults` (parsed RAOs/matrices)\n\nThere is no bridge from \"OrcaWaveRunner completed\" to \"here are parsed DiffractionResults\". The existing `BatchProcessor._process_orcawave()` at line 198 expects a `source_path` pointing to an existing `.sim` file and calls `OrcaWaveConverter` directly. It does not know how to run OrcaWave from a spec, wait for it, then extract results.\n\nAdditionally, there are no RAO plots anywhere in the diffraction module. The legacy `rao_analysis.py` at `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/rao_analysis/rao_analysis.py` uses Plotly `make_subplots` with 6 rows for DOFs, but it reads from OrcaFlex YAML vessel type files, not `DiffractionResults`. No Polars usage exists in the project (only Pandas).\n\n---\n\n## 2. DATA FLOW DIAGRAM\n\n```\nDiffractionSpec (spec.yml)                    [INPUT]\n  |\n  v\nOrcaWaveBatchConfig                           [NEW - batch definition]\n  |  (list of specs + run configurations)\n  v\nOrcaWaveBatchRunner.run()                     [NEW - orchestrator]\n  |\n  |-- for each spec (sequential or parallel):\n  |     |\n  |     v\n  |   OrcaWaveRunner.run(spec)                [EXISTING - WRK-029]\n  |     |\n  |     v\n  |   RunResult (status, output_dir, paths)   [EXISTING]\n  |     |\n  |     v\n  |   ResultExtractor.extract(run_result)     [NEW - bridge]\n  |     |  (finds .sim in output_dir, loads via OrcaWaveConverter)\n  |     v\n  |   DiffractionResults                      [EXISTING schema]\n  |     |\n  |     v\n  |   OutputValidator.run_all_validations()   [EXISTING + extended]\n  |     |\n  |     v\n  |   RAOPlotter.generate_plots()             [NEW - Plotly HTML]\n  |     |\n  |     v\n  |   PolarsExporter.to_polars()              [NEW - Polars DataFrame export]\n  |\n  v\nOrcaWaveBatchReport                           [NEW - aggregated report]\n  |\n  v\nHTML summary + JSON + per-vessel outputs      [OUTPUT]\n```\n\n---\n\n## 3. FILES TO CREATE AND MODIFY\n\n### New Files (6 files)\n\n| # | File | Est. Lines | Purpose |\n|---|------|-----------|---------|\n| 1 | `src/.../diffraction/result_extractor.py` | ~120 | Bridge: RunResult -> DiffractionResults |\n| 2 | `src/.../diffraction/orcawave_batch_runner.py` | ~350 | New batch orchestrator using OrcaWaveRunner |\n| 3 | `src/.../diffraction/rao_plotter.py` | ~380 | Plotly interactive HTML plots (amp + phase, 6 DOF) |\n| 4 | `src/.../diffraction/polars_exporter.py` | ~200 | Polars DataFrame export + CSV |\n| 5 | `tests/.../diffraction/test_result_extractor.py` | ~120 | Tests for bridge |\n| 6 | `tests/.../diffraction/test_orcawave_batch_runner.py` | ~300 | Tests for batch runner |\n| 7 | `tests/.../diffraction/test_rao_plotter.py` | ~250 | Tests for plotting |\n| 8 | `tests/.../diffraction/test_polars_exporter.py` | ~150 | Tests for Polars export |\n\n### Modified Files (4 files)\n\n| # | File | Changes |\n|---|------|---------|\n| 1 | `src/.../diffraction/__init__.py` | Add new exports |\n| 2 | `src/.../diffraction/cli.py` | Add `batch-orcawave` and `plot-raos` commands |\n| 3 | `src/.../diffraction/output_validator.py` | Add resonance detection validation |\n| 4 | `tests/.../diffraction/conftest.py` | Add shared fixtures for mock DiffractionResults |\n\n---\n\n## 4. CLASS AND FUNCTION SIGNATURES\n\n### 4.1 `result_extractor.py` (~120 lines)\n\nThis is the critical bridge between WRK-029's `RunResult` and the existing `OrcaWaveConverter`.\n\n```python\n\"\"\"Bridge between OrcaWaveRunner.RunResult and DiffractionResults.\n\nABOUTME: Locates OrcaWave output model files (.sim/.dat) in run output\ndirectories and extracts parsed DiffractionResults using OrcaWaveConverter.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom dataclasses import dataclass, field\n\nfrom digitalmodel.hydrodynamics.diffraction.orcawave_runner import RunResult, RunStatus\nfrom digitalmodel.hydrodynamics.diffraction.output_schemas import DiffractionResults\n\n\n@dataclass\nclass ExtractionResult:\n    \"\"\"Result of extracting DiffractionResults from a RunResult.\"\"\"\n    success: bool\n    results: DiffractionResults | None = None\n    model_file: Path | None = None\n    error_message: str | None = None\n\n\nclass ResultExtractor:\n    \"\"\"Extract DiffractionResults from OrcaWaveRunner output.\n\n    Bridges the gap between RunResult (file paths + status) and\n    DiffractionResults (parsed RAOs, added mass, damping).\n    \"\"\"\n\n    # OrcaWave output file patterns, ordered by priority\n    MODEL_FILE_PATTERNS: list[str] = [\"*.sim\", \"*.dat\"]\n\n    def __init__(\n        self,\n        vessel_name: str | None = None,\n        water_depth: float | None = None,\n    ) -> None: ...\n\n    def extract(self, run_result: RunResult) -> ExtractionResult:\n        \"\"\"Extract DiffractionResults from a completed RunResult.\n\n        Args:\n            run_result: Result from OrcaWaveRunner.run().\n\n        Returns:\n            ExtractionResult with parsed data or error info.\n\n        Raises:\n            ValueError: If run_result status is not COMPLETED.\n        \"\"\"\n        ...\n\n    def find_model_file(self, output_dir: Path) -> Path | None:\n        \"\"\"Locate the OrcaWave output model file in the output directory.\n\n        Searches for .sim then .dat files.\n\n        Args:\n            output_dir: Directory containing OrcaWave outputs.\n\n        Returns:\n            Path to model file, or None if not found.\n        \"\"\"\n        ...\n\n    def _extract_water_depth(self, run_result: RunResult) -> float:\n        \"\"\"Determine water depth from RunResult context or spec.\"\"\"\n        ...\n```\n\n### 4.2 `orcawave_batch_runner.py` (~350 lines)\n\nNew batch orchestrator that uses `OrcaWaveRunner` (WRK-029) instead of calling `OrcaWaveConverter` directly.\n\n```python\n\"\"\"OrcaWave batch analysis runner (WRK-030).\n\nABOUTME: Batch execution of OrcaWave diffraction analyses from DiffractionSpec\nfiles. Supports sequential and parallel modes with full postprocessing pipeline.\n\nData flow::\n\n    List[BatchJobConfig]\n      -> OrcaWaveBatchRunner.run()\n      -> for each job: OrcaWaveRunner.run() -> ResultExtractor.extract()\n      -> DiffractionResults -> validate -> plot -> export\n      -> OrcaWaveBatchReport\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field\n\nfrom digitalmodel.hydrodynamics.diffraction.input_schemas import DiffractionSpec\nfrom digitalmodel.hydrodynamics.diffraction.orcawave_runner import RunConfig, RunResult\nfrom digitalmodel.hydrodynamics.diffraction.output_schemas import DiffractionResults\n\n\nclass ExecutionMode(str, Enum):\n    \"\"\"Batch execution mode.\"\"\"\n    SEQUENTIAL = \"sequential\"\n    PARALLEL = \"parallel\"\n\n\nclass BatchJobConfig(BaseModel):\n    \"\"\"Configuration for a single batch job.\n\n    Each job pairs a DiffractionSpec with run-specific overrides.\n    \"\"\"\n    spec_path: Path = Field(..., description=\"Path to spec YAML file\")\n    job_name: str | None = Field(None, description=\"Human-readable job name\")\n    output_dir: Path | None = Field(None, description=\"Per-job output directory override\")\n    dry_run: bool = Field(False, description=\"Dry-run override for this job\")\n    water_depth_override: float | None = Field(\n        None, description=\"Override water depth for extraction\"\n    )\n    validate: bool = Field(True, description=\"Run validation after extraction\")\n    generate_plots: bool = Field(True, description=\"Generate RAO plots\")\n    export_formats: list[str] = Field(\n        default_factory=lambda: [\"csv\", \"polars\"],\n        description=\"Export formats: csv, polars, excel\",\n    )\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n\nclass OrcaWaveBatchConfig(BaseModel):\n    \"\"\"Top-level batch configuration.\"\"\"\n    jobs: list[BatchJobConfig]\n    execution_mode: ExecutionMode = ExecutionMode.SEQUENTIAL\n    max_workers: int = Field(default=4, gt=0)\n    base_output_dir: Path = Field(default=Path(\"batch_output\"))\n    run_config: RunConfig = Field(default_factory=RunConfig)\n    generate_summary_report: bool = True\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    @classmethod\n    def from_yaml(cls, path: Path) -> OrcaWaveBatchConfig: ...\n\n\n@dataclass\nclass BatchJobResult:\n    \"\"\"Result of a single batch job.\"\"\"\n    job_name: str\n    status: str  # \"success\", \"error\", \"skipped\", \"dry_run\"\n    run_result: RunResult | None = None\n    diffraction_results: DiffractionResults | None = None\n    validation_report: dict[str, Any] | None = None\n    plot_files: list[Path] = field(default_factory=list)\n    export_files: dict[str, Path] = field(default_factory=dict)\n    execution_time: float = 0.0\n    error_message: str | None = None\n\n\n@dataclass\nclass OrcaWaveBatchReport:\n    \"\"\"Aggregated batch report.\"\"\"\n    start_time: str\n    end_time: str\n    total_duration: float\n    total_jobs: int\n    successful: int\n    failed: int\n    skipped: int\n    job_results: list[BatchJobResult] = field(default_factory=list)\n    summary_statistics: dict[str, Any] = field(default_factory=dict)\n\n\nclass OrcaWaveBatchRunner:\n    \"\"\"Execute batch OrcaWave analyses with postprocessing.\n\n    Orchestrates: run -> extract -> validate -> plot -> export.\n    \"\"\"\n\n    def __init__(self, config: OrcaWaveBatchConfig) -> None: ...\n\n    def run(self) -> OrcaWaveBatchReport:\n        \"\"\"Execute all batch jobs per the configuration.\n\n        Returns:\n            OrcaWaveBatchReport with all job results.\n        \"\"\"\n        ...\n\n    def _run_sequential(self) -> list[BatchJobResult]: ...\n\n    def _run_parallel(self) -> list[BatchJobResult]: ...\n\n    def _process_single_job(self, job: BatchJobConfig) -> BatchJobResult:\n        \"\"\"Process a single batch job: run -> extract -> validate -> plot -> export.\n\n        Args:\n            job: Job configuration.\n\n        Returns:\n            BatchJobResult with all outputs.\n        \"\"\"\n        ...\n\n    def _run_solver(\n        self, spec: DiffractionSpec, job: BatchJobConfig\n    ) -> RunResult: ...\n\n    def _extract_results(\n        self, run_result: RunResult, job: BatchJobConfig\n    ) -> DiffractionResults | None: ...\n\n    def _validate_results(\n        self, results: DiffractionResults, output_dir: Path\n    ) -> dict[str, Any]: ...\n\n    def _generate_plots(\n        self, results: DiffractionResults, output_dir: Path\n    ) -> list[Path]: ...\n\n    def _export_results(\n        self, results: DiffractionResults, output_dir: Path, formats: list[str]\n    ) -> dict[str, Path]: ...\n\n    def _build_report(\n        self, job_results: list[BatchJobResult], start: datetime\n    ) -> OrcaWaveBatchReport: ...\n\n    def export_report(\n        self, report: OrcaWaveBatchReport, output_file: Path\n    ) -> None: ...\n\n\n# Module-level convenience functions\n\ndef run_orcawave_batch(\n    config_path: Path,\n) -> OrcaWaveBatchReport:\n    \"\"\"Run an OrcaWave batch analysis from a YAML configuration file.\"\"\"\n    ...\n\ndef run_orcawave_batch_from_specs(\n    spec_paths: list[Path],\n    output_dir: Path = Path(\"batch_output\"),\n    dry_run: bool = False,\n    parallel: bool = False,\n) -> OrcaWaveBatchReport:\n    \"\"\"Convenience: run batch from a list of spec file paths.\"\"\"\n    ...\n```\n\n### 4.3 `rao_plotter.py` (~380 lines)\n\nFull interactive Plotly HTML plots for RAO visualization. Follows the layout pattern from the legacy `rao_analysis.py` (6-row subplots, shared x-axis), but built from `DiffractionResults` directly.\n\n```python\n\"\"\"RAO plotting with Plotly interactive HTML (WRK-030).\n\nABOUTME: Generates interactive Plotly HTML plots for RAO amplitude and phase\nacross all 6 DOFs. Supports per-heading traces, period/frequency x-axis,\nand combined amplitude+phase layout.\n\nLayout convention (matches legacy rao_analysis.py):\n- 6 rows x 1 column, shared x-axis\n- DOF order: Surge, Sway, Heave, Roll, Pitch, Yaw\n- One trace per heading angle\n- Shared legend across subplots\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Literal\n\nimport numpy as np\n\nfrom digitalmodel.hydrodynamics.diffraction.output_schemas import (\n    DiffractionResults, RAOSet, RAOComponent, DOF\n)\n\n\n# DOF display order and labels\nDOF_ORDER: list[DOF] = [\n    DOF.SURGE, DOF.SWAY, DOF.HEAVE,\n    DOF.ROLL, DOF.PITCH, DOF.YAW,\n]\nDOF_LABELS: dict[DOF, str] = {\n    DOF.SURGE: \"Surge\", DOF.SWAY: \"Sway\", DOF.HEAVE: \"Heave\",\n    DOF.ROLL: \"Roll\", DOF.PITCH: \"Pitch\", DOF.YAW: \"Yaw\",\n}\nAMPLITUDE_UNITS: dict[DOF, str] = {\n    DOF.SURGE: \"m/m\", DOF.SWAY: \"m/m\", DOF.HEAVE: \"m/m\",\n    DOF.ROLL: \"deg/m\", DOF.PITCH: \"deg/m\", DOF.YAW: \"deg/m\",\n}\n\n\nclass RAOPlotter:\n    \"\"\"Generate interactive Plotly HTML plots from DiffractionResults.\"\"\"\n\n    def __init__(\n        self,\n        results: DiffractionResults,\n        output_dir: Path,\n        x_axis: Literal[\"period\", \"frequency\"] = \"period\",\n    ) -> None: ...\n\n    def plot_all(self) -> list[Path]:\n        \"\"\"Generate all RAO plots (amplitude, phase, combined).\n\n        Returns:\n            List of generated HTML file paths.\n        \"\"\"\n        ...\n\n    def plot_amplitude(\n        self,\n        headings: list[float] | None = None,\n    ) -> Path:\n        \"\"\"Generate 6-DOF amplitude RAO plot.\n\n        Args:\n            headings: Specific headings to plot. None = all.\n\n        Returns:\n            Path to generated HTML file.\n        \"\"\"\n        ...\n\n    def plot_phase(\n        self,\n        headings: list[float] | None = None,\n    ) -> Path:\n        \"\"\"Generate 6-DOF phase RAO plot.\n\n        Args:\n            headings: Specific headings to plot. None = all.\n\n        Returns:\n            Path to generated HTML file.\n        \"\"\"\n        ...\n\n    def plot_combined(\n        self,\n        headings: list[float] | None = None,\n    ) -> Path:\n        \"\"\"Generate combined amplitude + phase plot (6 rows x 2 cols).\n\n        Args:\n            headings: Specific headings to plot. None = all.\n\n        Returns:\n            Path to generated HTML file.\n        \"\"\"\n        ...\n\n    def plot_single_dof(\n        self,\n        dof: DOF,\n        headings: list[float] | None = None,\n    ) -> Path:\n        \"\"\"Generate amplitude + phase plot for a single DOF.\n\n        Args:\n            dof: Degree of freedom to plot.\n            headings: Specific headings. None = all.\n\n        Returns:\n            Path to generated HTML file.\n        \"\"\"\n        ...\n\n    # --- Private helpers ---\n\n    def _create_amplitude_figure(\n        self,\n        headings: list[float],\n    ) -> Any:  # plotly.graph_objects.Figure\n        \"\"\"Create 6-row subplot figure for amplitude.\"\"\"\n        ...\n\n    def _create_phase_figure(\n        self,\n        headings: list[float],\n    ) -> Any:\n        \"\"\"Create 6-row subplot figure for phase.\"\"\"\n        ...\n\n    def _create_combined_figure(\n        self,\n        headings: list[float],\n    ) -> Any:\n        \"\"\"Create 6-row x 2-col subplot figure (amplitude + phase).\"\"\"\n        ...\n\n    def _add_dof_traces(\n        self,\n        fig: Any,\n        component: RAOComponent,\n        headings: list[float],\n        row: int,\n        col: int,\n        value_type: Literal[\"amplitude\", \"phase\"],\n        show_legend: bool,\n    ) -> None:\n        \"\"\"Add traces for one DOF to a subplot.\"\"\"\n        ...\n\n    def _get_x_values(self, component: RAOComponent) -> np.ndarray:\n        \"\"\"Get x-axis values (period or frequency) based on config.\"\"\"\n        ...\n\n    def _get_heading_indices(\n        self, component: RAOComponent, headings: list[float] | None\n    ) -> list[int]:\n        \"\"\"Map heading values to array indices.\"\"\"\n        ...\n\n    def _get_heading_colors(self, n: int) -> list[str]:\n        \"\"\"Generate distinct colors for heading traces.\"\"\"\n        ...\n\n    def _apply_layout(\n        self, fig: Any, title: str\n    ) -> None:\n        \"\"\"Apply consistent layout styling to figure.\"\"\"\n        ...\n\n    def _save_figure(self, fig: Any, filename: str) -> Path:\n        \"\"\"Save figure as interactive HTML.\"\"\"\n        ...\n```\n\n### 4.4 `polars_exporter.py` (~200 lines)\n\nPolars DataFrame export. No existing Polars usage in the project (only `import polars` in some unrelated files), so this introduces the pattern.\n\n```python\n\"\"\"Polars DataFrame export for DiffractionResults (WRK-030).\n\nABOUTME: Converts DiffractionResults to Polars DataFrames for analysis.\nProvides CSV export using Polars as primary library with Pandas fallback.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any\n\nimport numpy as np\n\nfrom digitalmodel.hydrodynamics.diffraction.output_schemas import (\n    DiffractionResults, DOF\n)\n\ntry:\n    import polars as pl\n    POLARS_AVAILABLE = True\nexcept ImportError:\n    POLARS_AVAILABLE = False\n\ntry:\n    import pandas as pd\n    PANDAS_AVAILABLE = True\nexcept ImportError:\n    PANDAS_AVAILABLE = False\n\n\nclass PolarsExporter:\n    \"\"\"Export DiffractionResults to Polars DataFrames and CSV.\"\"\"\n\n    def __init__(self, results: DiffractionResults) -> None: ...\n\n    def raos_to_polars(self) -> pl.DataFrame:\n        \"\"\"Convert RAOs to a long-format Polars DataFrame.\n\n        Columns: frequency, period, heading, dof, amplitude, phase, unit\n\n        Returns:\n            Polars DataFrame with all RAO data.\n\n        Raises:\n            ImportError: If Polars is not installed.\n        \"\"\"\n        ...\n\n    def added_mass_to_polars(self) -> pl.DataFrame:\n        \"\"\"Convert added mass matrices to Polars DataFrame.\n\n        Columns: frequency, period, dof_i, dof_j, value, unit\n\n        Returns:\n            Polars DataFrame.\n        \"\"\"\n        ...\n\n    def damping_to_polars(self) -> pl.DataFrame:\n        \"\"\"Convert damping matrices to Polars DataFrame.\n\n        Columns: frequency, period, dof_i, dof_j, value, unit\n\n        Returns:\n            Polars DataFrame.\n        \"\"\"\n        ...\n\n    def raos_to_pandas(self) -> pd.DataFrame:\n        \"\"\"Convert RAOs to Pandas DataFrame (fallback).\n\n        Returns:\n            Pandas DataFrame with same structure as Polars version.\n        \"\"\"\n        ...\n\n    def export_raos_csv(self, output_dir: Path) -> Path:\n        \"\"\"Export RAOs to CSV using Polars (Pandas fallback).\n\n        Args:\n            output_dir: Output directory.\n\n        Returns:\n            Path to generated CSV file.\n        \"\"\"\n        ...\n\n    def export_added_mass_csv(self, output_dir: Path) -> Path:\n        \"\"\"Export added mass to CSV.\"\"\"\n        ...\n\n    def export_damping_csv(self, output_dir: Path) -> Path:\n        \"\"\"Export damping to CSV.\"\"\"\n        ...\n\n    def export_all_csv(self, output_dir: Path) -> dict[str, Path]:\n        \"\"\"Export all data to CSV files.\n\n        Returns:\n            Dict mapping data type to file path.\n        \"\"\"\n        ...\n\n    def _build_rao_records(self) -> list[dict[str, Any]]:\n        \"\"\"Build list of RAO records for DataFrame construction.\"\"\"\n        ...\n\n    def _build_matrix_records(\n        self, matrix_type: str\n    ) -> list[dict[str, Any]]:\n        \"\"\"Build list of matrix records for DataFrame construction.\"\"\"\n        ...\n```\n\n### 4.5 Modifications to `output_validator.py`\n\nAdd resonance detection to the existing `OutputValidator` class:\n\n```python\n# NEW METHOD in OutputValidator class:\n\ndef _validate_resonance(self) -> dict[str, list[str]]:\n    \"\"\"Detect potential resonance peaks in RAO data.\n\n    Checks for:\n    - Sharp peaks (magnitude ratio to neighbors > threshold)\n    - Peaks at physically expected frequencies\n    - Excessive amplification factors\n\n    Returns:\n        Dictionary of resonance validation issues.\n    \"\"\"\n    ...\n```\n\nThe `run_all_validations()` method would also call `_validate_resonance()` and include it in the report under a new `resonance_checks` key.\n\n### 4.6 Modifications to `cli.py`\n\nAdd two new CLI commands:\n\n```python\n@cli.command(\"batch-orcawave\")\n@click.argument(\"config_path\", type=click.Path(exists=True))\n@click.option(\"--output\", \"-o\", type=click.Path(), default=\"batch_output\")\n@click.option(\"--mode\", \"-m\",\n    type=click.Choice([\"sequential\", \"parallel\"]),\n    default=\"sequential\")\n@click.option(\"--dry-run\", is_flag=True, default=False)\n@click.option(\"--max-workers\", \"-w\", type=int, default=4)\ndef batch_orcawave_cmd(config_path, output, mode, dry_run, max_workers):\n    \"\"\"Run batch OrcaWave analysis from a YAML configuration file.\n\n    CONFIG_PATH: Path to batch configuration YAML.\n\n    Example:\n        diffraction batch-orcawave batch_config.yml --mode parallel -w 4\n        diffraction batch-orcawave batch_config.yml --dry-run\n    \"\"\"\n    ...\n\n\n@cli.command(\"plot-raos\")\n@click.argument(\"model_file\", type=click.Path(exists=True))\n@click.option(\"--vessel-name\", \"-v\", type=str, default=None)\n@click.option(\"--water-depth\", \"-d\", type=float, required=True)\n@click.option(\"--output\", \"-o\", type=click.Path(), default=\"plots\")\n@click.option(\"--x-axis\", type=click.Choice([\"period\", \"frequency\"]),\n    default=\"period\")\n@click.option(\"--headings\", type=str, default=None,\n    help=\"Comma-separated heading values to plot\")\ndef plot_raos_cmd(model_file, vessel_name, water_depth, output, x_axis, headings):\n    \"\"\"Generate interactive RAO plots from OrcaWave/OrcaFlex model file.\n\n    MODEL_FILE: Path to .sim or .dat model file.\n\n    Example:\n        diffraction plot-raos model.sim -d 500 -o ./plots\n        diffraction plot-raos model.sim -d 500 --x-axis frequency\n    \"\"\"\n    ...\n```\n\n### 4.7 Modifications to `__init__.py`\n\nAdd the following exports:\n\n```python\n# WRK-030: Batch runner + postprocessing\nfrom digitalmodel.hydrodynamics.diffraction.result_extractor import (\n    ResultExtractor,\n    ExtractionResult,\n)\nfrom digitalmodel.hydrodynamics.diffraction.orcawave_batch_runner import (\n    OrcaWaveBatchRunner,\n    OrcaWaveBatchConfig,\n    BatchJobConfig,\n    BatchJobResult,\n    OrcaWaveBatchReport,\n    ExecutionMode,\n    run_orcawave_batch,\n    run_orcawave_batch_from_specs,\n)\nfrom digitalmodel.hydrodynamics.diffraction.rao_plotter import RAOPlotter\nfrom digitalmodel.hydrodynamics.diffraction.polars_exporter import PolarsExporter\n```\n\n### 4.8 Modifications to `conftest.py`\n\nAdd shared mock fixtures:\n\n```python\n@pytest.fixture\ndef mock_diffraction_results() -> DiffractionResults:\n    \"\"\"Create synthetic DiffractionResults for testing without OrcFxAPI.\"\"\"\n    ...\n\n@pytest.fixture\ndef mock_rao_set() -> RAOSet:\n    \"\"\"Create synthetic RAOSet with realistic shapes.\"\"\"\n    ...\n\n@pytest.fixture\ndef batch_config_path(tmp_path: Path, ship_raos_spec_path: Path) -> Path:\n    \"\"\"Create a temporary batch configuration YAML file.\"\"\"\n    ...\n```\n\n---\n\n## 5. INTEGRATION POINTS\n\n| New Component | Connects To | How |\n|---|---|---|\n| `ResultExtractor` | `RunResult` (WRK-029) | Reads `run_result.output_dir`, finds `.sim` files |\n| `ResultExtractor` | `OrcaWaveConverter` (existing) | Calls `converter.convert_to_unified_schema()` |\n| `OrcaWaveBatchRunner` | `OrcaWaveRunner` (WRK-029) | Creates runner per job, calls `runner.run()` |\n| `OrcaWaveBatchRunner` | `ResultExtractor` | Calls `extractor.extract(run_result)` |\n| `OrcaWaveBatchRunner` | `OutputValidator` (existing) | Calls `validate_results()` |\n| `OrcaWaveBatchRunner` | `RAOPlotter` | Calls `plotter.plot_all()` |\n| `OrcaWaveBatchRunner` | `PolarsExporter` | Calls `exporter.export_all_csv()` |\n| `RAOPlotter` | `DiffractionResults` (existing) | Reads `results.raos` for all 6 DOFs |\n| `PolarsExporter` | `DiffractionResults` (existing) | Reads all data fields |\n| CLI `batch-orcawave` | `OrcaWaveBatchRunner` | Instantiates and runs |\n| CLI `plot-raos` | `OrcaWaveConverter` + `RAOPlotter` | Converts then plots |\n| `OutputValidator` | Extended with `_validate_resonance()` | New validation category |\n\n---\n\n## 6. TDD IMPLEMENTATION ORDER\n\nThe implementation follows strict TDD (Red-Green-Refactor) and is ordered by dependency:\n\n### Phase 1: Foundation (no solver dependency)\n\n**Step 1: Mock DiffractionResults fixture** (conftest.py)\n- Create `mock_diffraction_results` fixture with synthetic numpy data\n- Verify it matches `DiffractionResults` schema\n- This enables all downstream testing without OrcFxAPI\n\n**Step 2: PolarsExporter** (polars_exporter.py)\n- RED: Test `raos_to_polars()` returns correct columns and row count\n- GREEN: Implement `_build_rao_records()` + `raos_to_polars()`\n- RED: Test `added_mass_to_polars()`, `damping_to_polars()`\n- GREEN: Implement `_build_matrix_records()` + matrix methods\n- RED: Test `export_raos_csv()` creates file\n- GREEN: Implement CSV export\n- RED: Test Pandas fallback when Polars unavailable\n- GREEN: Implement `raos_to_pandas()`\n- REFACTOR: Extract shared record-building logic\n\n**Step 3: RAOPlotter** (rao_plotter.py)\n- RED: Test `plot_amplitude()` creates HTML file\n- GREEN: Implement `_create_amplitude_figure()` + `plot_amplitude()`\n- RED: Test `plot_phase()` creates HTML file\n- GREEN: Implement `_create_phase_figure()` + `plot_phase()`\n- RED: Test `plot_combined()` creates HTML file with both panels\n- GREEN: Implement `_create_combined_figure()` + `plot_combined()`\n- RED: Test `plot_single_dof()` for each DOF\n- GREEN: Implement `plot_single_dof()`\n- RED: Test heading filtering (subset of headings)\n- GREEN: Implement `_get_heading_indices()`\n- RED: Test x-axis switching (period vs frequency)\n- GREEN: Implement `_get_x_values()`\n- REFACTOR: Extract `_add_dof_traces()` helper\n\n### Phase 2: Bridge (connects WRK-029 output to results)\n\n**Step 4: ResultExtractor** (result_extractor.py)\n- RED: Test `find_model_file()` finds `.sim` in directory\n- GREEN: Implement glob-based file search\n- RED: Test `find_model_file()` returns None for empty directory\n- GREEN: Handle empty case\n- RED: Test `extract()` raises for non-COMPLETED status\n- GREEN: Add status validation\n- RED: Test `extract()` returns ExtractionResult on success (mock converter)\n- GREEN: Implement full extraction with mocked `OrcaWaveConverter`\n- RED: Test `extract()` returns error on missing model file\n- GREEN: Handle missing file gracefully\n- REFACTOR: Clean up error messages\n\n### Phase 3: Batch Runner (orchestrator)\n\n**Step 5: OrcaWaveBatchRunner** (orcawave_batch_runner.py)\n- RED: Test `BatchJobConfig` defaults and validation\n- GREEN: Implement Pydantic model\n- RED: Test `OrcaWaveBatchConfig.from_yaml()` loads config\n- GREEN: Implement YAML loading\n- RED: Test `_process_single_job()` in dry-run mode\n- GREEN: Implement single job processing\n- RED: Test `_run_sequential()` processes multiple jobs\n- GREEN: Implement sequential loop\n- RED: Test `_run_parallel()` processes concurrently\n- GREEN: Implement `ProcessPoolExecutor` path\n- RED: Test `run()` returns `OrcaWaveBatchReport` with correct counts\n- GREEN: Implement `run()` + `_build_report()`\n- RED: Test `export_report()` creates JSON\n- GREEN: Implement JSON export\n- RED: Test convenience function `run_orcawave_batch()`\n- GREEN: Implement module-level function\n- REFACTOR: Extract statistics calculation\n\n### Phase 4: Validation Extension + CLI\n\n**Step 6: OutputValidator resonance detection** (output_validator.py)\n- RED: Test `_validate_resonance()` detects sharp peaks\n- GREEN: Implement peak detection\n- RED: Test resonance check integrates into `run_all_validations()`\n- GREEN: Add call in validation pipeline\n\n**Step 7: CLI commands** (cli.py)\n- RED: Test `batch-orcawave` command with `--dry-run`\n- GREEN: Implement `batch_orcawave_cmd()`\n- RED: Test `plot-raos` command generates HTML\n- GREEN: Implement `plot_raos_cmd()` (mock converter)\n\n---\n\n## 7. TEST PLAN\n\n### `test_result_extractor.py` (~120 lines, ~12 tests)\n\n| Test Class | Tests | What It Tests |\n|---|---|---|\n| `TestExtractionResult` | 2 | Dataclass defaults, custom values |\n| `TestResultExtractorFindModel` | 3 | Find .sim, find .dat, return None |\n| `TestResultExtractorExtract` | 5 | Happy path (mock), non-COMPLETED status, missing file, converter error, water depth override |\n| `TestResultExtractorEdgeCases` | 2 | Multiple .sim files (picks first), dry_run result |\n\n### `test_orcawave_batch_runner.py` (~300 lines, ~25 tests)\n\n| Test Class | Tests | What It Tests |\n|---|---|---|\n| `TestBatchJobConfig` | 4 | Defaults, custom values, validation, path coercion |\n| `TestOrcaWaveBatchConfig` | 4 | Defaults, from_yaml, execution modes, run_config nesting |\n| `TestBatchJobResult` | 2 | Defaults, custom values |\n| `TestOrcaWaveBatchReport` | 2 | Defaults, statistics aggregation |\n| `TestOrcaWaveBatchRunnerSequential` | 5 | Single job dry-run, multi-job, error handling, validation integration, report generation |\n| `TestOrcaWaveBatchRunnerParallel` | 3 | Multi-job parallel, max_workers respected, error isolation |\n| `TestOrcaWaveBatchRunnerPostprocess` | 3 | Plots generated, CSV exported, validation included |\n| `TestBatchConvenience` | 2 | `run_orcawave_batch()`, `run_orcawave_batch_from_specs()` |\n\n### `test_rao_plotter.py` (~250 lines, ~20 tests)\n\n| Test Class | Tests | What It Tests |\n|---|---|---|\n| `TestRAOPlotterInit` | 2 | Constructor, x-axis options |\n| `TestPlotAmplitude` | 4 | Creates HTML, correct filename, all headings, filtered headings |\n| `TestPlotPhase` | 3 | Creates HTML, correct y-axis labels, heading filtering |\n| `TestPlotCombined` | 3 | Creates HTML, 2 columns, all DOFs present |\n| `TestPlotSingleDof` | 3 | Each DOF type, period vs frequency, heading subset |\n| `TestPlotAll` | 2 | Returns multiple paths, all files exist |\n| `TestPlotLayout` | 3 | Title, legend, axis labels |\n\n### `test_polars_exporter.py` (~150 lines, ~15 tests)\n\n| Test Class | Tests | What It Tests |\n|---|---|---|\n| `TestRaosToPolars` | 4 | Column names, row count, data types, values match source |\n| `TestAddedMassToPolars` | 3 | Column names, row count, frequency values |\n| `TestDampingToPolars` | 2 | Column names, values match source |\n| `TestCsvExport` | 3 | File creation, content verification, all-export |\n| `TestPandasFallback` | 3 | raos_to_pandas(), column consistency with Polars version |\n\n**Total new tests: ~72**\n\n---\n\n## 8. CLI COMMANDS\n\n### New Commands\n\n| Command | Arguments | Options | Description |\n|---|---|---|---|\n| `batch-orcawave` | `CONFIG_PATH` | `--output`, `--mode`, `--dry-run`, `--max-workers` | Run batch OrcaWave from YAML config |\n| `plot-raos` | `MODEL_FILE` | `--vessel-name`, `--water-depth`, `--output`, `--x-axis`, `--headings` | Generate interactive RAO plots from model file |\n\n### Example Batch Config YAML\n\n```yaml\njobs:\n  - spec_path: specs/ship_001.yml\n    job_name: Ship_001_500m\n    validate: true\n    generate_plots: true\n    export_formats: [csv, polars]\n\n  - spec_path: specs/semisub.yml\n    job_name: Semisub_1200m\n    water_depth_override: 1200.0\n    validate: true\n    generate_plots: true\n\nexecution_mode: sequential\nbase_output_dir: ./batch_results\nrun_config:\n  dry_run: false\n  timeout_seconds: 3600\n  generate_modular: true\ngenerate_summary_report: true\n```\n\n---\n\n## 9. VERIFICATION COMMANDS\n\nAfter implementation, verify with:\n\n```bash\n# 1. Run all new tests\nuv run pytest tests/hydrodynamics/diffraction/test_result_extractor.py -v\nuv run pytest tests/hydrodynamics/diffraction/test_orcawave_batch_runner.py -v\nuv run pytest tests/hydrodynamics/diffraction/test_rao_plotter.py -v\nuv run pytest tests/hydrodynamics/diffraction/test_polars_exporter.py -v\n\n# 2. Run existing tests (regression)\nuv run pytest tests/hydrodynamics/diffraction/ -v\n\n# 3. Check coverage\nuv run pytest tests/hydrodynamics/diffraction/ --cov=digitalmodel.hydrodynamics.diffraction --cov-report=term-missing\n\n# 4. CLI smoke tests (dry-run)\nuv run python -m digitalmodel.hydrodynamics.diffraction.cli batch-orcawave batch_config.yml --dry-run\nuv run python -m digitalmodel.hydrodynamics.diffraction.cli plot-raos model.sim -d 500 --output plots\n\n# 5. Type checking (if mypy configured)\nuv run mypy src/digitalmodel/hydrodynamics/diffraction/result_extractor.py\nuv run mypy src/digitalmodel/hydrodynamics/diffraction/orcawave_batch_runner.py\nuv run mypy src/digitalmodel/hydrodynamics/diffraction/rao_plotter.py\nuv run mypy src/digitalmodel/hydrodynamics/diffraction/polars_exporter.py\n```\n\n---\n\n## 10. KEY DESIGN DECISIONS\n\n1. **New `OrcaWaveBatchRunner` rather than modifying existing `BatchProcessor`**: The existing `BatchProcessor` at `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/batch_processor.py` works with pre-existing `.sim` files and `OrcaWaveConverter`. WRK-030 needs a fundamentally different flow: spec -> run solver -> extract from output. Rather than contorting the old class, a new class provides cleaner separation. The old `BatchProcessor` remains for legacy conversion-only workflows.\n\n2. **`ResultExtractor` as separate class**: This keeps the bridge logic isolated and testable without mocking the full runner. It also enables standalone use -- an engineer could extract results from any directory of OrcaWave outputs without running the full batch pipeline.\n\n3. **Polars primary with Pandas fallback**: Polars is not yet used in this project. The `PolarsExporter` introduces it as the primary DataFrame library with a runtime check (`POLARS_AVAILABLE`). If Polars is not installed, it falls back to Pandas (which is already a dependency via `OrcaFlexExporter`). This matches the requirement without breaking existing code.\n\n4. **Plotly interactive HTML only (no static images)**: Per project rules in `CLAUDE.md` (\"Interactive plots only (Plotly/Bokeh)\") and the WRK-030 spec. The legacy `rao_analysis.py` already uses `fig.write_html()` for output. The new `RAOPlotter` follows this pattern exclusively.\n\n5. **Layout: 6 rows x 1 col for amplitude/phase separately; 6 rows x 2 cols for combined**: The legacy code uses `make_subplots(rows=6, cols=1)` for each. The combined view adds phase alongside amplitude for a comprehensive single-page view.\n\n6. **ProcessPoolExecutor for parallel mode**: Matches the existing pattern in `BatchProcessor.run()` at line 241. Note: `OrcaWaveConverter` (which uses OrcFxAPI) may not be picklable across processes. The parallel mode should be used for the solver execution step; extraction may need to happen in the main process or use `ThreadPoolExecutor` as a safe alternative.\n\n---\n\n### Critical Files for Implementation\n- `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/orcawave_runner.py` - Source of RunResult that the new ResultExtractor bridges from\n- `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/orcawave_converter.py` - OrcaWaveConverter that ResultExtractor delegates to for parsing\n- `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/output_schemas.py` - DiffractionResults/RAOSet/DOF schemas consumed by plotter and exporter\n- `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/batch_processor.py` - Existing batch pattern to follow (but not modify)\n- `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/cli.py` - CLI to extend with batch-orcawave and plot-raos commands","session":"34e7aefe-7340-4181-a078-0f77741b7255"}
