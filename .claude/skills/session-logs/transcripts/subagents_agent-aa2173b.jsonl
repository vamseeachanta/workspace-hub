{"ts":"2026-02-03T04:02:04.475Z","role":"ai","text":"\n\nI'll explore the codebase thoroughly to understand the existing architecture before designing the implementation plan.","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:05.311Z","role":"ai","text":"[tool:Bash]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:06.978Z","role":"ai","text":"[tool:Bash]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:08.598Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:08.572Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:13.200Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:13.155Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:16.634Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:22.982Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:22.960Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:29.241Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:29.911Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:36.357Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:40.122Z","role":"ai","text":"Now let me read the remaining critical files.","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:40.696Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:47.273Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:47.245Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:53.812Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:02:54.376Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:01.347Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:06.398Z","role":"ai","text":"Now let me examine the existing test file and test fixtures to understand testing patterns.","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:07.171Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:13.839Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:13.813Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:20.428Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:25.214Z","role":"ai","text":"Now let me look at the directory structure and the `__init__.py` for the diffraction module, plus the output schemas.","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:26.232Z","role":"ai","text":"[tool:Bash]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:27.750Z","role":"ai","text":"[tool:Bash]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:29.394Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:29.369Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:35.952Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:35.919Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:40.000Z","role":"ai","text":"Let me now read the conftest and the `__init__.py` for the diffraction module to understand imports and available fixtures.","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:40.417Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:47.263Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:47.229Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:53.700Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:03:54.274Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:04:00.711Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:04:05.581Z","role":"ai","text":"Let me also check the existing orchestrator's approach to running OrcaWave to understand what the executable invocation looks like, and look at the pyproject.toml for dependencies.","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:04:06.945Z","role":"ai","text":"[tool:Bash]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:04:08.406Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:04:15.086Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:04:15.049Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:04:15.727Z","role":"ai","text":"[tool:Glob]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:04:20.488Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:04:24.002Z","role":"ai","text":"[tool:Read]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:04:30.469Z","role":"human","text":"[result]","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
{"ts":"2026-02-03T04:06:33.133Z","role":"ai","text":"I now have a thorough understanding of the entire architecture. Let me present the comprehensive implementation plan.\n\n---\n\n## WRK-029 Implementation Plan: OrcaWave Diffraction Analysis Runner\n\n### 1. Architecture Overview\n\nThe runner sits between the existing `OrcaWaveBackend` (which generates input files) and the batch pipeline. The data flow is:\n\n```\nDiffractionSpec (YAML)\n    |\n    v\nOrcaWaveBackend.generate_single/modular() -- already exists\n    |\n    v\nOrcaWaveRunner.prepare() -- validates spec, generates files, locates mesh\n    |\n    v\nOrcaWaveRunner.execute() -- finds OrcaWave.exe, runs subprocess, captures logs\n    |\n    v\nRunResult -- status, paths, duration, logs\n```\n\nThe runner is designed around two core principles from the requirements:\n\n**No-license mode (dry-run)**: When OrcaWave is not installed (CI, Linux, Mac), the runner still generates input files, validates them, and returns a `RunResult` with `status=DRY_RUN`. This enables full TDD without the solver.\n\n**Modular file structure decision**: The runner defaults to **single-file mode** for OrcaWave invocation because OrcaWave's batch mode (`-batch`) expects a single `.yml` project file as input. Modular files are generated alongside for human review and parametric study reuse, but the solver consumes the single merged file. This is documented in the `OrcaWaveRunner` class docstring.\n\n### 2. New Files\n\n#### 2.1 `src/digitalmodel/hydrodynamics/diffraction/orcawave_runner.py` (~350 lines)\n\nThis is the core deliverable. Contains three classes and one public function.\n\n**Pydantic v2 models (top of file):**\n\n```python\n\"\"\"OrcaWave diffraction analysis runner (WRK-029).\n\nExecutes OrcaWave diffraction analysis from a canonical DiffractionSpec.\nGenerates input files via OrcaWaveBackend, locates the OrcaWave executable,\ninvokes the solver, and captures run status and logs.\n\nSupports dry-run mode when OrcaWave is not installed (CI/Linux/Mac).\nIn dry-run mode, input files are generated and validated but the solver\nis not invoked.\n\nModular file structure rationale:\n    OrcaWave batch mode requires a single .yml project file as input.\n    The runner generates a single merged file for solver consumption\n    AND modular section files alongside for human review, parametric\n    study reuse, and debugging. The master.yml is the solver input;\n    modular files (01_general.yml, 02_units.yml, ...) are reference\n    artifacts only.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport platform\nimport shutil\nimport subprocess\nimport time\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\nfrom digitalmodel.hydrodynamics.diffraction.input_schemas import DiffractionSpec\nfrom digitalmodel.hydrodynamics.diffraction.orcawave_backend import OrcaWaveBackend\n\nlogger = logging.getLogger(__name__)\n```\n\n**RunStatus enum:**\n\n```python\nclass RunStatus(str, Enum):\n    \"\"\"Execution status of an OrcaWave run.\"\"\"\n    PENDING = \"pending\"\n    PREPARING = \"preparing\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    DRY_RUN = \"dry_run\"\n    CANCELLED = \"cancelled\"\n```\n\n**RunConfig (Pydantic v2):**\n\n```python\nclass RunConfig(BaseModel):\n    \"\"\"Configuration for an OrcaWave runner execution.\n\n    Attributes:\n        executable_path: Path to orcawave.exe. If None, auto-detected\n            from standard installation locations.\n        output_dir: Directory for generated files and results.\n        dry_run: If True, generate files but skip solver invocation.\n            Defaults to True when OrcaWave is not detected.\n        timeout_seconds: Maximum solver execution time in seconds.\n            Default 7200 (2 hours).\n        generate_modular: Also generate modular section files alongside\n            the single merged file. Default True.\n        copy_mesh_files: Copy mesh files to output directory for\n            self-contained runs. Default True.\n        log_level: Logging verbosity for solver execution.\n        extra_args: Additional command-line arguments passed to OrcaWave.\n    \"\"\"\n    executable_path: Optional[Path] = Field(\n        None,\n        description=\"Path to orcawave.exe (auto-detected if None)\",\n    )\n    output_dir: Path = Field(\n        default=Path(\"output/orcawave_run\"),\n        description=\"Directory for output files\",\n    )\n    dry_run: bool = Field(\n        default=False,\n        description=\"Generate files without running solver\",\n    )\n    timeout_seconds: int = Field(\n        default=7200,\n        gt=0,\n        description=\"Solver timeout in seconds\",\n    )\n    generate_modular: bool = Field(\n        default=True,\n        description=\"Also generate modular section files\",\n    )\n    copy_mesh_files: bool = Field(\n        default=True,\n        description=\"Copy mesh files to output directory\",\n    )\n    log_level: str = Field(\n        default=\"INFO\",\n        description=\"Log level for runner\",\n    )\n    extra_args: list[str] = Field(\n        default_factory=list,\n        description=\"Additional OrcaWave CLI arguments\",\n    )\n```\n\n**RunResult (dataclass, not Pydantic -- results are returned, not validated as input):**\n\n```python\n@dataclass\nclass RunResult:\n    \"\"\"Outcome of an OrcaWave runner execution.\n\n    Attributes:\n        status: Final run status.\n        input_file: Path to the generated OrcaWave .yml input file.\n        modular_files: Paths to modular section files (empty if not generated).\n        output_dir: Directory containing all run artifacts.\n        mesh_files: Paths to mesh files used/copied.\n        log_file: Path to captured solver log (None if dry_run).\n        stdout: Captured solver stdout.\n        stderr: Captured solver stderr.\n        return_code: Solver process return code (None if dry_run).\n        duration_seconds: Wall-clock run time in seconds.\n        error_message: Error description if status is FAILED.\n        spec_name: Analysis name derived from spec.\n    \"\"\"\n    status: RunStatus\n    input_file: Optional[Path] = None\n    modular_files: list[Path] = field(default_factory=list)\n    output_dir: Optional[Path] = None\n    mesh_files: list[Path] = field(default_factory=list)\n    log_file: Optional[Path] = None\n    stdout: str = \"\"\n    stderr: str = \"\"\n    return_code: Optional[int] = None\n    duration_seconds: float = 0.0\n    error_message: Optional[str] = None\n    spec_name: str = \"\"\n```\n\n**OrcaWaveRunner class:**\n\n```python\nclass OrcaWaveRunner:\n    \"\"\"Runs OrcaWave diffraction analysis from a DiffractionSpec.\n\n    Workflow:\n        1. prepare(spec) -- Generate input files, copy mesh, validate\n        2. execute() -- Run OrcaWave (or skip in dry_run mode)\n        3. result property -- Access RunResult\n\n    Example::\n\n        runner = OrcaWaveRunner(RunConfig(output_dir=Path(\"run_01\")))\n        result = runner.run(spec)\n        print(result.status, result.input_file)\n\n    For batch integration (WRK-030), use the run() convenience method\n    which calls prepare() then execute() in sequence.\n    \"\"\"\n\n    def __init__(self, config: RunConfig | None = None) -> None: ...\n\n    def run(self, spec: DiffractionSpec) -> RunResult:\n        \"\"\"Full pipeline: prepare + execute. Returns RunResult.\"\"\"\n\n    def prepare(self, spec: DiffractionSpec) -> RunResult:\n        \"\"\"Generate input files and validate. Does NOT run solver.\n        Returns RunResult with status PREPARING or DRY_RUN.\"\"\"\n\n    def execute(self) -> RunResult:\n        \"\"\"Execute the solver on prepared files. Must call prepare() first.\n        Returns RunResult with final status.\"\"\"\n\n    @property\n    def result(self) -> RunResult | None:\n        \"\"\"Access the most recent RunResult.\"\"\"\n\n    # --- Private methods ---\n\n    def _detect_executable(self) -> Path | None:\n        \"\"\"Find OrcaWave executable in standard locations.\n        Returns None if not found (triggers dry_run).\"\"\"\n\n    def _generate_input_files(\n        self, spec: DiffractionSpec, output_dir: Path\n    ) -> tuple[Path, list[Path]]:\n        \"\"\"Use OrcaWaveBackend to generate single + optional modular files.\n        Returns (single_file_path, list_of_modular_paths).\"\"\"\n\n    def _copy_mesh_files(\n        self, spec: DiffractionSpec, output_dir: Path\n    ) -> list[Path]:\n        \"\"\"Copy referenced mesh files to output directory.\n        Returns list of copied mesh paths.\"\"\"\n\n    def _validate_mesh_references(\n        self, spec: DiffractionSpec, output_dir: Path\n    ) -> list[str]:\n        \"\"\"Check that all mesh files referenced in spec exist\n        in or relative to output_dir. Returns list of issues.\"\"\"\n\n    def _invoke_solver(\n        self,\n        executable: Path,\n        input_file: Path,\n        output_dir: Path,\n        timeout: int,\n        extra_args: list[str],\n    ) -> tuple[int, str, str]:\n        \"\"\"Run orcawave.exe as subprocess. Returns (returncode, stdout, stderr).\"\"\"\n\n    def _capture_log(self, output_dir: Path) -> Path | None:\n        \"\"\"Find and return path to solver log file in output_dir.\"\"\"\n```\n\nKey implementation details for private methods:\n\n`_detect_executable()` searches these paths (same as existing orchestrator):\n- `C:\\Program Files\\Orcina\\OrcaWave\\bin\\orcawave.exe`\n- `C:\\Program Files (x86)\\Orcina\\OrcaWave\\bin\\orcawave.exe`\n- Also checks `ORCAWAVE_PATH` environment variable\n- Also checks `shutil.which(\"orcawave\")`\n- Returns `None` if not found on non-Windows platforms or when not installed\n\n`_invoke_solver()` runs:\n```python\nsubprocess.run(\n    [str(executable), str(input_file), \"-batch\", \"-output-dir\", str(output_dir)]\n    + extra_args,\n    capture_output=True,\n    text=True,\n    timeout=timeout,\n    cwd=str(output_dir),\n)\n```\n\nThis mirrors the batch script's invocation pattern (`%ORCAWAVE_PATH% -config \"%CONFIG_FILE%\" -batch -output-dir \"%RESULTS_DIR%\"`) but translates it from .bat to pure Python subprocess calls.\n\n**Convenience function:**\n\n```python\ndef run_orcawave(\n    spec: DiffractionSpec,\n    output_dir: Path,\n    dry_run: bool = False,\n    timeout_seconds: int = 7200,\n) -> RunResult:\n    \"\"\"One-shot convenience function for running OrcaWave.\n\n    Creates an OrcaWaveRunner with default config and runs the spec.\n    For fine-grained control, use OrcaWaveRunner directly.\n    \"\"\"\n    config = RunConfig(\n        output_dir=output_dir,\n        dry_run=dry_run,\n        timeout_seconds=timeout_seconds,\n    )\n    runner = OrcaWaveRunner(config)\n    return runner.run(spec)\n```\n\n#### 2.2 `tests/hydrodynamics/diffraction/test_orcawave_runner.py` (~350 lines)\n\nTDD test file written **before** implementation. Organized into test classes that mirror the runner's responsibilities.\n\n```python\n\"\"\"Tests for OrcaWave diffraction runner (WRK-029).\n\nTDD: These tests define the expected behavior of OrcaWaveRunner,\nRunConfig, RunResult, and the run_orcawave convenience function.\n\nAll tests use dry_run=True mode since OrcaWave is not available in CI.\nTests validate:\n- File preparation (input generation, mesh copying)\n- Configuration validation\n- Run lifecycle (prepare -> execute -> result)\n- Error handling\n- CLI integration (run-orcawave command)\n- Batch pipeline compatibility\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom unittest.mock import patch, MagicMock\n\nimport pytest\nimport yaml\n\nfrom digitalmodel.hydrodynamics.diffraction.input_schemas import DiffractionSpec\n\nFIXTURES_DIR = Path(__file__).parent / \"fixtures\"\n\n\ndef _ship_spec() -> DiffractionSpec:\n    return DiffractionSpec.from_yaml(FIXTURES_DIR / \"spec_ship_raos.yml\")\n\n\ndef _semisub_spec() -> DiffractionSpec:\n    return DiffractionSpec.from_yaml(FIXTURES_DIR / \"spec_semisub.yml\")\n\n\ndef _multibody_spec() -> DiffractionSpec:\n    return DiffractionSpec.from_yaml(FIXTURES_DIR / \"spec_fpso_turret.yml\")\n```\n\n**Test classes and methods (signatures only, grouped by responsibility):**\n\n```python\nclass TestRunConfig:\n    \"\"\"RunConfig Pydantic model validation.\"\"\"\n\n    def test_default_config_is_valid(self): ...\n    def test_custom_executable_path(self): ...\n    def test_timeout_must_be_positive(self): ...\n    def test_dry_run_defaults_to_false(self): ...\n    def test_extra_args_accepted(self): ...\n\n\nclass TestRunResult:\n    \"\"\"RunResult dataclass properties.\"\"\"\n\n    def test_default_result_has_pending_status(self): ...\n    def test_result_stores_input_file_path(self): ...\n    def test_result_stores_duration(self): ...\n\n\nclass TestRunStatus:\n    \"\"\"RunStatus enum values.\"\"\"\n\n    def test_all_statuses_defined(self): ...\n    def test_status_is_string_enum(self): ...\n\n\nclass TestOrcaWaveRunnerPrepare:\n    \"\"\"Test file preparation without solver execution.\"\"\"\n\n    def test_prepare_generates_single_yml(self, tmp_path): ...\n    def test_prepare_generates_modular_files_when_enabled(self, tmp_path): ...\n    def test_prepare_skips_modular_when_disabled(self, tmp_path): ...\n    def test_prepare_creates_output_directory(self, tmp_path): ...\n    def test_prepare_returns_result_with_input_file(self, tmp_path): ...\n    def test_prepare_copies_mesh_files(self, tmp_path): ...\n    def test_prepare_sets_status_to_dry_run_when_no_executable(self, tmp_path): ...\n    def test_prepare_validates_spec(self, tmp_path): ...\n    def test_generated_yml_is_valid_orcawave_format(self, tmp_path): ...\n    def test_generated_yml_contains_all_required_keys(self, tmp_path): ...\n\n\nclass TestOrcaWaveRunnerExecute:\n    \"\"\"Test solver execution (mocked since OrcaWave unavailable in CI).\"\"\"\n\n    def test_execute_without_prepare_raises(self, tmp_path): ...\n    def test_dry_run_skips_solver_invocation(self, tmp_path): ...\n    def test_dry_run_returns_dry_run_status(self, tmp_path): ...\n    def test_dry_run_records_duration(self, tmp_path): ...\n\n    @patch(\"subprocess.run\")\n    def test_execute_calls_subprocess_with_correct_args(\n        self, mock_run, tmp_path\n    ): ...\n\n    @patch(\"subprocess.run\")\n    def test_execute_captures_stdout_stderr(\n        self, mock_run, tmp_path\n    ): ...\n\n    @patch(\"subprocess.run\")\n    def test_execute_handles_timeout(\n        self, mock_run, tmp_path\n    ): ...\n\n    @patch(\"subprocess.run\")\n    def test_execute_handles_nonzero_return_code(\n        self, mock_run, tmp_path\n    ): ...\n\n    @patch(\"subprocess.run\")\n    def test_execute_sets_completed_on_success(\n        self, mock_run, tmp_path\n    ): ...\n\n\nclass TestOrcaWaveRunnerRun:\n    \"\"\"Test full run() pipeline (prepare + execute).\"\"\"\n\n    def test_run_dry_run_returns_dry_run_status(self, tmp_path): ...\n    def test_run_produces_input_files(self, tmp_path): ...\n    def test_run_with_ship_spec(self, tmp_path): ...\n    def test_run_with_semisub_spec(self, tmp_path): ...\n    def test_run_with_multibody_spec(self, tmp_path): ...\n    def test_run_result_has_spec_name(self, tmp_path): ...\n\n\nclass TestOrcaWaveRunnerDetectExecutable:\n    \"\"\"Test executable detection logic.\"\"\"\n\n    def test_returns_none_when_not_found(self): ...\n\n    @patch(\"shutil.which\", return_value=\"/usr/local/bin/orcawave\")\n    def test_uses_shutil_which_fallback(self, mock_which): ...\n\n    def test_uses_env_var_when_set(self): ...\n\n    @patch(\"platform.system\", return_value=\"Linux\")\n    def test_returns_none_on_linux(self, mock_platform): ...\n\n\nclass TestOrcaWaveRunnerMeshHandling:\n    \"\"\"Test mesh file copying and validation.\"\"\"\n\n    def test_copy_mesh_creates_file_in_output(self, tmp_path): ...\n    def test_validate_mesh_reports_missing_file(self, tmp_path): ...\n    def test_mesh_reference_relative_to_spec(self, tmp_path): ...\n\n\nclass TestRunOrcawaveConvenience:\n    \"\"\"Test the run_orcawave() convenience function.\"\"\"\n\n    def test_run_orcawave_dry_run(self, tmp_path): ...\n    def test_run_orcawave_returns_run_result(self, tmp_path): ...\n    def test_run_orcawave_creates_output_dir(self, tmp_path): ...\n```\n\n### 3. Modifications to Existing Files\n\n#### 3.1 `src/digitalmodel/hydrodynamics/diffraction/cli.py`\n\nAdd a new `run-orcawave` command after the existing `validate-spec` command (around line 500). The command follows the same pattern as `convert-spec`:\n\n```python\n@cli.command(\"run-orcawave\")\n@click.argument(\"spec_path\", type=click.Path(exists=True))\n@click.option(\n    \"--output\", \"-o\",\n    type=click.Path(),\n    default=\"output/orcawave_run\",\n    help=\"Output directory (default: output/orcawave_run)\",\n)\n@click.option(\n    \"--dry-run/--no-dry-run\",\n    default=False,\n    help=\"Generate files without running solver\",\n)\n@click.option(\n    \"--timeout\", \"-t\",\n    type=int,\n    default=7200,\n    help=\"Solver timeout in seconds (default: 7200)\",\n)\n@click.option(\n    \"--executable\",\n    type=click.Path(),\n    default=None,\n    help=\"Path to orcawave.exe (auto-detect if not specified)\",\n)\n@click.option(\n    \"--modular/--no-modular\",\n    default=True,\n    help=\"Generate modular section files alongside (default: True)\",\n)\ndef run_orcawave_cmd(spec_path, output, dry_run, timeout, executable, modular):\n    \"\"\"Run OrcaWave diffraction analysis from a DiffractionSpec YAML.\n\n    SPEC_PATH: Path to a spec.yml file conforming to DiffractionSpec schema.\n\n    Example:\n        diffraction run-orcawave analysis.yml --dry-run\n        diffraction run-orcawave analysis.yml -o ./results --timeout 3600\n    \"\"\"\n    from digitalmodel.hydrodynamics.diffraction.orcawave_runner import (\n        OrcaWaveRunner,\n        RunConfig,\n        RunStatus,\n    )\n\n    click.echo(\"=\" * 80)\n    click.echo(\"OrcaWave Runner\")\n    click.echo(\"=\" * 80)\n    # ... (config display, run, result display)\n```\n\nThis adds approximately 50 lines. The CLI file is currently 505 lines, bringing it to ~555 lines. Since the cli.py currently handles many commands, this is within bounds but worth watching.\n\n#### 3.2 `src/digitalmodel/hydrodynamics/diffraction/__init__.py`\n\nAdd imports for the new runner classes at the bottom of the existing imports (around line 78, before `__all__`):\n\n```python\nfrom digitalmodel.hydrodynamics.diffraction.orcawave_runner import (\n    OrcaWaveRunner,\n    RunConfig,\n    RunResult,\n    RunStatus,\n    run_orcawave,\n)\n```\n\nAdd to `__all__`:\n```python\n    # Runner (WRK-029)\n    'OrcaWaveRunner',\n    'RunConfig',\n    'RunResult',\n    'RunStatus',\n    'run_orcawave',\n```\n\n#### 3.3 `tests/hydrodynamics/diffraction/conftest.py`\n\nAdd a fixture for the runner config and a dry-run runner:\n\n```python\n@pytest.fixture\ndef dry_run_config(tmp_path: Path) -> \"RunConfig\":\n    \"\"\"RunConfig with dry_run=True for CI testing.\"\"\"\n    from digitalmodel.hydrodynamics.diffraction.orcawave_runner import RunConfig\n    return RunConfig(output_dir=tmp_path, dry_run=True)\n```\n\n### 4. Test Strategy\n\n**TDD approach**: Write `test_orcawave_runner.py` first, run tests to see failures, then implement `orcawave_runner.py`.\n\n**Dry-run is the test backbone**: Since OrcaWave is Windows-only commercial software not available in CI, ALL tests use `dry_run=True` or mock `subprocess.run`. The dry-run path exercises 90% of the code: spec validation, file generation, mesh copying, directory creation, and result construction. Only the actual subprocess invocation is mocked.\n\n**Three testing layers:**\n\n1. **Unit tests** (no mocking needed): `TestRunConfig`, `TestRunResult`, `TestRunStatus` -- test the data models directly.\n\n2. **Integration tests** (dry-run mode): `TestOrcaWaveRunnerPrepare`, `TestOrcaWaveRunnerRun`, `TestOrcaWaveRunnerMeshHandling` -- use real `DiffractionSpec` fixtures, generate real files to `tmp_path`, assert file contents and structure.\n\n3. **Mock tests** (subprocess mocked): `TestOrcaWaveRunnerExecute` -- mock `subprocess.run` to test execution logic, timeout handling, error handling, and stdout/stderr capture.\n\n**Coverage target**: 80%+ on `orcawave_runner.py`. The only uncovered lines should be the `_detect_executable` method's actual file-system checks for `C:\\Program Files\\Orcina\\...` paths, which are platform-specific.\n\n### 5. Implementation Order\n\nAll steps follow TDD: write the test, see it fail, implement, see it pass.\n\n**Step 1: Data models (Red-Green cycle)**\n1. Write `TestRunStatus`, `TestRunConfig`, `TestRunResult` in `test_orcawave_runner.py`\n2. Implement `RunStatus`, `RunConfig`, `RunResult` in `orcawave_runner.py`\n3. Run tests -- all should pass\n\n**Step 2: File preparation (Red-Green cycle)**\n1. Write `TestOrcaWaveRunnerPrepare` tests\n2. Implement `OrcaWaveRunner.__init__()`, `prepare()`, `_generate_input_files()`, `_copy_mesh_files()`, `_validate_mesh_references()`\n3. Run tests -- all should pass\n\n**Step 3: Execution (Red-Green cycle)**\n1. Write `TestOrcaWaveRunnerExecute` tests (with mocks)\n2. Implement `execute()`, `_detect_executable()`, `_invoke_solver()`, `_capture_log()`\n3. Run tests -- all should pass\n\n**Step 4: Full run pipeline (Red-Green cycle)**\n1. Write `TestOrcaWaveRunnerRun` tests\n2. Implement `run()` (which is just `prepare()` then `execute()`)\n3. Run tests -- all should pass\n\n**Step 5: Convenience function**\n1. Write `TestRunOrcawaveConvenience` tests\n2. Implement `run_orcawave()` module-level function\n3. Run tests\n\n**Step 6: CLI integration**\n1. Write CLI test class in `test_orcawave_runner.py`:\n    ```python\n    class TestCLIRunOrcawave:\n        def test_run_orcawave_dry_run_exit_0(self, tmp_path): ...\n        def test_run_orcawave_help(self): ...\n    ```\n2. Add `run-orcawave` command to `cli.py`\n3. Run tests\n\n**Step 7: Module registration**\n1. Update `__init__.py` with new imports\n2. Update `conftest.py` with new fixture\n3. Run full test suite to verify no regressions\n\n### 6. Integration Points\n\n#### With `batch_processor.py` (WRK-030)\nThe `BatchProcessor._process_orcawave()` method currently uses `OrcaWaveConverter` to extract results from completed OrcaWave runs. The runner adds the missing upstream capability: **running the analysis**. In WRK-030, `BatchProcessor` will gain a new source type (e.g., `\"orcawave_spec\"`) that:\n1. Takes a `DiffractionSpec` instead of a pre-existing model file\n2. Calls `OrcaWaveRunner.run(spec)` to generate files and optionally run the solver\n3. Then calls `OrcaWaveConverter` on the results\n\nThe `RunResult` dataclass is designed to be passed directly into the batch processor's result tracking. Its fields (`status`, `duration_seconds`, `output_files`, `error_message`) map directly to `BatchResult`.\n\n#### With `SpecConverter`\nThe existing `SpecConverter` routes specs to backends for file generation only. The runner does NOT modify `SpecConverter`. Instead, it uses `OrcaWaveBackend` directly. The runner is a higher-level abstraction:\n\n```\nSpecConverter --> OrcaWaveBackend --> .yml files (generation only)\nOrcaWaveRunner --> OrcaWaveBackend --> .yml files --> orcawave.exe --> results\n```\n\n#### With the legacy orchestrator (`solvers/orcawave/diffraction/orchestrator.py`)\nThe legacy `OrcaWaveOrchestrator` remains untouched. It uses raw YAML configs and batch scripts. The new `OrcaWaveRunner` is a modern replacement that uses the canonical `DiffractionSpec` system. Migration from the old orchestrator to the new runner is a separate task.\n\n### 7. Design Decisions and Rationale\n\n**Why `RunConfig` is Pydantic v2 but `RunResult` is a dataclass**: `RunConfig` is user-supplied input that benefits from Pydantic validation (positive timeout, valid paths). `RunResult` is output-only, constructed internally, and does not need input validation overhead.\n\n**Why single-file for solver + modular for reference**: OrcaWave's CLI accepts one `.yml` file. Generating modular files alongside provides:\n- Debuggability (each section in its own file)\n- Reuse (swap one section file for parametric studies)\n- Traceability (diff individual sections between runs)\n\n**Why not extend `SpecConverter`**: `SpecConverter` is a pure file converter. Adding execution responsibility would violate Single Responsibility Principle. The runner composes `OrcaWaveBackend` rather than extending `SpecConverter`.\n\n**Why the runner is not in `solvers/orcawave/`**: The `solvers/orcawave/` directory contains the legacy orchestrator with its own config system. The new runner belongs with the canonical spec system in `hydrodynamics/diffraction/` to maintain cohesion with `OrcaWaveBackend` and `SpecConverter`.\n\n### 8. Potential Challenges\n\n1. **Mesh file path resolution**: The spec stores mesh paths relative to the spec.yml location, but the runner's output directory is different. The `_copy_mesh_files()` method needs to resolve the original path (relative to spec location OR absolute) and copy to the output directory, then update the generated YAML to reference the local copy.\n\n2. **OrcaWave CLI argument format**: The batch script uses `-config`, `-batch`, `-output-dir` flags. The actual OrcaWave CLI may have different argument naming conventions across versions. The `extra_args` field in `RunConfig` provides an escape hatch. The runner should log the exact command it constructs before invocation.\n\n3. **Subprocess on Windows**: `subprocess.run` needs `shell=False` (no `shell=True` for security). The executable path must be properly quoted. On Windows, the `.exe` extension is required.\n\n4. **Log file discovery**: OrcaWave writes log files with timestamped names. The `_capture_log()` method needs to scan the output directory for the most recent `.txt` or `.log` file after execution.\n\n### Critical Files for Implementation\n\n- `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/orcawave_runner.py` - New file: core runner class, RunConfig, RunResult, RunStatus, convenience function\n- `D:/workspace-hub/digitalmodel/tests/hydrodynamics/diffraction/test_orcawave_runner.py` - New file: TDD tests written before implementation\n- `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/orcawave_backend.py` - Existing: OrcaWaveBackend consumed by the runner for file generation\n- `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/cli.py` - Existing: add `run-orcawave` CLI command\n- `D:/workspace-hub/digitalmodel/src/digitalmodel/hydrodynamics/diffraction/__init__.py` - Existing: register new exports","session":"b5a65278-a77d-4aca-abe2-d2050f0fc821"}
