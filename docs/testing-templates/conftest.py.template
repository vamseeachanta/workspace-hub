# conftest.py Template
#
# Pytest configuration and shared fixtures
# Copy this file to your tests/ directory as 'conftest.py'
#
# This file contains shared fixtures and configuration for all tests

import pytest
import os
import tempfile
from pathlib import Path
from typing import Generator, Any
from unittest.mock import Mock, patch

# Set testing environment
os.environ['TESTING'] = 'true'


# Basic fixtures
@pytest.fixture(scope="session")
def temp_dir() -> Generator[Path, None, None]:
    """Create a temporary directory for test files."""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)


@pytest.fixture(scope="function")
def mock_logger():
    """Mock logger for testing."""
    return Mock()


@pytest.fixture(scope="function")
def sample_data() -> dict[str, Any]:
    """Sample data for testing."""
    return {
        "id": 1,
        "name": "Test Item",
        "description": "A test item for testing purposes",
        "active": True,
        "metadata": {
            "created_at": "2025-01-01T00:00:00Z",
            "tags": ["test", "sample"]
        }
    }


# File system fixtures
@pytest.fixture(scope="function")
def temp_file(temp_dir: Path) -> Generator[Path, None, None]:
    """Create a temporary file for testing."""
    test_file = temp_dir / "test_file.txt"
    test_file.write_text("Test content")
    yield test_file


@pytest.fixture(scope="function")
def empty_temp_file(temp_dir: Path) -> Generator[Path, None, None]:
    """Create an empty temporary file for testing."""
    test_file = temp_dir / "empty_file.txt"
    test_file.touch()
    yield test_file


# Mock fixtures
@pytest.fixture(scope="function")
def mock_requests():
    """Mock requests library for HTTP testing."""
    with patch('requests.Session') as mock_session:
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"status": "success"}
        mock_response.text = '{"status": "success"}'
        mock_session.return_value.get.return_value = mock_response
        mock_session.return_value.post.return_value = mock_response
        yield mock_session


@pytest.fixture(scope="function")
def mock_database():
    """Mock database connection for testing."""
    with patch('your_module.database') as mock_db:
        # Configure mock database behavior
        mock_db.connect.return_value = Mock()
        mock_db.execute.return_value = []
        mock_db.fetch_one.return_value = None
        mock_db.fetch_all.return_value = []
        yield mock_db


# Environment fixtures
@pytest.fixture(scope="function")
def test_env_vars():
    """Set test environment variables."""
    test_vars = {
        'TEST_MODE': 'true',
        'DEBUG': 'false',
        'DATABASE_URL': 'sqlite:///:memory:',
        'API_KEY': 'test-api-key'
    }

    # Store original values
    original_values = {}
    for key, value in test_vars.items():
        original_values[key] = os.environ.get(key)
        os.environ[key] = value

    yield test_vars

    # Restore original values
    for key, original_value in original_values.items():
        if original_value is None:
            os.environ.pop(key, None)
        else:
            os.environ[key] = original_value


# Async fixtures (uncomment if using async tests)
# @pytest.fixture(scope="session")
# def event_loop():
#     """Create an instance of the default event loop for the test session."""
#     import asyncio
#     loop = asyncio.get_event_loop_policy().new_event_loop()
#     yield loop
#     loop.close()


# @pytest_asyncio.fixture
# async def async_client():
#     """Async HTTP client for testing."""
#     import httpx
#     async with httpx.AsyncClient() as client:
#         yield client


# Database fixtures (uncomment if using database)
# @pytest.fixture(scope="function")
# def db_session():
#     """Database session for testing."""
#     from your_module.database import SessionLocal, engine, Base
#
#     # Create tables
#     Base.metadata.create_all(bind=engine)
#
#     # Create session
#     session = SessionLocal()
#
#     try:
#         yield session
#     finally:
#         session.close()
#         # Drop tables
#         Base.metadata.drop_all(bind=engine)


# Custom markers
def pytest_configure(config):
    """Configure pytest markers."""
    config.addinivalue_line("markers", "unit: mark test as a unit test")
    config.addinivalue_line("markers", "integration: mark test as an integration test")
    config.addinivalue_line("markers", "e2e: mark test as an end-to-end test")
    config.addinivalue_line("markers", "slow: mark test as slow running")
    config.addinivalue_line("markers", "api: mark test as an API test")
    config.addinivalue_line("markers", "database: mark test as requiring database")
    config.addinivalue_line("markers", "external: mark test as requiring external services")


# Pytest hooks
def pytest_collection_modifyitems(config, items):
    """Modify test collection to add markers based on test location."""
    for item in items:
        # Add markers based on test file location
        if "unit" in str(item.fspath):
            item.add_marker(pytest.mark.unit)
        elif "integration" in str(item.fspath):
            item.add_marker(pytest.mark.integration)
        elif "e2e" in str(item.fspath):
            item.add_marker(pytest.mark.e2e)
            item.add_marker(pytest.mark.slow)


# Fixtures for specific testing scenarios
@pytest.fixture(scope="function")
def mock_time():
    """Mock time functions for consistent testing."""
    import time
    import datetime

    fixed_time = datetime.datetime(2025, 1, 1, 12, 0, 0)
    fixed_timestamp = fixed_time.timestamp()

    with patch('time.time', return_value=fixed_timestamp), \
         patch('datetime.datetime') as mock_datetime:
        mock_datetime.now.return_value = fixed_time
        mock_datetime.utcnow.return_value = fixed_time
        yield fixed_time


@pytest.fixture(scope="function")
def captured_logs(caplog):
    """Capture log messages for testing."""
    import logging
    caplog.set_level(logging.DEBUG)
    yield caplog


# Performance testing fixtures (uncomment if needed)
# @pytest.fixture(scope="function")
# def benchmark_settings():
#     """Settings for benchmark tests."""
#     return {
#         'max_time': 1.0,  # Maximum time per test in seconds
#         'min_rounds': 10,  # Minimum number of test rounds
#         'warmup': True,    # Enable warmup rounds
#     }