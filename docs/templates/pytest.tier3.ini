# ============================================================================
# pytest.tier3.ini - Tier 3 Repository Override Template
# ============================================================================
# Use this for MAINTENANCE repositories:
#   - All repositories not in Tier 1 or Tier 2
#   - Includes: doris, saipem, OGManufacturing, seanation, hobbies, etc.
#
# These repositories are in maintenance mode or experimental. Lower
# coverage requirements with more relaxed constraints allow flexibility.
#
# Installation:
#   1. Copy to repository root as: pytest.ini
#   2. Customize repository-specific settings
#   3. Commit to version control
#
# Coverage Philosophy:
#   Tier 3 repos maintain 75% coverage minimum. This balances maintenance
#   effort with code quality. Focus on critical functionality.
#   Use as opportunity to improve code quality incrementally.
#
# ============================================================================

[pytest]

# Inherit from base configuration, override specific settings
testpaths = tests
python_files = test_*.py *_test.py
python_classes = Test*
python_functions = test_*

# Markers (inherited from base, can be extended)
markers =
    unit: Unit tests - Test single functions/methods in isolation
    integration: Integration tests - Test interaction between components
    e2e: End-to-end tests - Test complete workflows from user perspective
    slow: Tests that take significant time (>2 seconds)
    flaky: Tests that sometimes fail intermittently
    database: Tests requiring database access
    api: Tests requiring external API calls (mocked or real)
    scrapy: Tests for Scrapy spiders or web scraping functionality
    selenium: Tests using Selenium for browser automation
    llm: Tests involving LLM calls (Claude, GPT, Gemini)

# ============================================================================
# TIER 3 SPECIFIC SETTINGS
# ============================================================================

# Relaxed coverage requirement for maintenance/experimental code
fail_under = 75

# More relaxed timeout for slower systems
timeout = 600

# Parallel execution with up to 12 workers (max performance)
# Enable with: -n 12
# Or use 'auto' to match CPU cores: -n auto
addopts =
    --verbose
    --tb=short
    -W default
    --strict-markers
    --strict-config
    --cov=src
    --cov-report=term-missing:skip-covered
    --cov-report=html:htmlcov
    --cov-report=xml
    --durations=10
    -n 12

# Asyncio configuration
asyncio_mode = auto

# ============================================================================
# Coverage Settings - Tier 3 Requirements
# ============================================================================
# Tier 3 requires 75% coverage minimum (opportunity for improvement)

[coverage:run]
source = src
omit =
    */tests/*
    */venv/*
    */__pycache__/*
    */site-packages/*
    setup.py
    conftest.py

exclude_lines =
    pragma: no cover
    def __repr__
    if self\.debug
    raise AssertionError
    raise NotImplementedError
    if __name__ == .__main__.:
    @abstractmethod
    @abc.abstractmethod
    if TYPE_CHECKING:

[coverage:report]
precision = 2
show_missing = True
skip_covered = False
fail_under = 75

[coverage:html]
directory = htmlcov

# ============================================================================
# Logging Configuration
# ============================================================================
# Standard logging for maintenance work

log_level = INFO
log_cli_level = INFO
log_capture = true
log_format = %(asctime)s [%(levelname)8s] %(name)s - %(message)s
log_date_format = %Y-%m-%d %H:%M:%S

# ============================================================================
# TIER 3 TESTING PHILOSOPHY
# ============================================================================
#
# Maintenance & Experimental Principle:
#   Focus on essential functionality with pragmatic coverage.
#   Lower barrier to entry allows easier maintenance and improvements.
#
# Test Strategy:
#   1. Unit Tests (focus on core functionality)
#      - Test important business logic
#      - Skip trivial getters/setters
#      - Target >80% for critical paths
#
#   2. Integration Tests (as needed)
#      - Test critical workflows
#      - Test data persistence
#
#   3. E2E Tests (optional)
#      - Only for user-facing features
#
# Quality Gates:
#   - Coverage <75%: Warn (not blocking)
#   - Critical test failure: Block merge
#   - Flaky test: Monitor, fix when convenient
#
# Local Development (Flexible):
#   # Quick test run
#   pytest tests/unit
#
#   # Run all tests
#   pytest
#
#   # Skip slow tests if needed
#   pytest -m "not slow"
#
# CI/CD Pipeline:
#   # Parallel testing with 12 workers
#   pytest -n 12 --cov
#
#   # Can be more lenient with timeouts
#   timeout = 600 seconds
#
# ============================================================================
# IMPROVEMENT OPPORTUNITIES FOR TIER 3
# ============================================================================
#
# Tier 3 repositories are candidates for improvement. Consider:
#
# 1. Coverage Improvement Plan
#    Current: 75% minimum
#    Target: 80% (move toward Tier 2)
#    Strategy: Add tests incrementally as you work on code
#
# 2. Test Suite Modernization
#    - Migrate old mocking patterns to pytest-mock
#    - Update async tests to use asyncio_mode = auto
#    - Consolidate duplicate test fixtures
#
# 3. Documentation Gaps
#    - Add docstrings to tested functions
#    - Document test purpose and assumptions
#    - Link tests to requirements
#
# 4. Performance Optimization
#    - Identify slow tests with --durations=10
#    - Add parallelization with pytest-xdist
#    - Use database transactions for test isolation
#
# ============================================================================
# CUSTOMIZATION FOR YOUR TIER 3 REPOSITORY
# ============================================================================
#
# Tier 3 repos often have specific needs. Customize as appropriate:
#
# If your repo is experimental:
# [pytest]
# markers =
#     experimental: Experimental features under development
#     deprecated: Old code scheduled for removal
#
# If your repo has optional dependencies:
#
#   # Skip tests for unavailable dependencies
#   pytest -m "not (selenium or llm)"
#
# If your repo needs lower timeouts (fast hardware):
#
#   [pytest]
#   timeout = 300  # Lower from 600
#
# If you want to improve coverage over time:
#
#   # Start at 75%, gradually increase
#   fail_under = 75  # Year 1
#   fail_under = 78  # Year 2
#   fail_under = 80  # Year 3 (target Tier 2)
#
# ============================================================================
# EXAMPLE: IMPROVE FROM TIER 3 TO TIER 2
# ============================================================================
#
# Step 1: Assess current state
#   pytest --cov --cov-report=html
#   # Open htmlcov/index.html to find untested code
#
# Step 2: Set improvement target
#   # Pick 5-10 most important modules
#   # Add tests to bring those to 85%+
#
# Step 3: Incrementally improve
#   # Each week, add tests for one module
#   # Monitor coverage with: pytest --cov
#
# Step 4: Update threshold
#   # Once at 80%, update pytest.ini:
#   fail_under = 80
#
# Step 5: Graduate to Tier 2
#   # Copy pytest.tier2.ini
#   # Update CI/CD to use -n 8 instead of -n 12
#
# ============================================================================
# MIGRATION GUIDE: TIER 3 → TIER 2 → TIER 1
# ============================================================================
#
# Tier 3 (Maintenance):
#   - Coverage: 75%+ (minimum)
#   - Timeout: 600s (relaxed)
#   - Parallelization: -n 12 (fast)
#   - Test Types: Unit + Critical Integration
#
# → IMPROVE COVERAGE TO 80%+ →
#
# Tier 2 (Active Development):
#   - Coverage: 80%+ (good)
#   - Timeout: 300s (standard)
#   - Parallelization: -n 8 (balanced)
#   - Test Types: Unit + Integration
#
# → IMPROVE COVERAGE TO 85%+ →
#
# Tier 1 (Production Critical):
#   - Coverage: 85%+ (strict)
#   - Timeout: 300s (conservative)
#   - Parallelization: -n 4 (safe)
#   - Test Types: Unit + Integration + E2E
#
# Each tier upgrade brings:
#   ✓ Higher code quality
#   ✓ More confidence in changes
#   ✓ Fewer production issues
#   ✓ Better developer experience
#
# ============================================================================
